{"title":"Webscraping básico con RSelenium","markdown":{"yaml":{"title":"Webscraping básico con RSelenium","execute":{"warning":false},"author":"Gabriel Ramírez","date":"12/23/2022","lang":"es","editor":"visual","csl":"apa.csl","bibliography":"references.bib","categories":["Webscraping","RSelenium","analysis"],"image":"image.jpg"},"headingText":"Contexto de SICOP","containsRefs":false,"markdown":"\n\n\nEn este proyecto se obtienen datos del Sistema Integrado de Compras Públicas ([SICOP](https://www.sicop.go.cr/index.jsp)) por municipalidad. El fin es realizar un análisis descriptivo y espacializar los datos por municipalidad o institución (cantón o localización de municipalidad).\n\nEste sistema se autodenomina como una novedosa herramienta para la realización de negocios vía web. De forma más específica, permite a las proveedurías del Estado realizar compra y venta de servicios y productos de forma electrónica.\n\nEste modelo de compras se realizó tras un análisis de prácticas efectuadas por países como Chile, Panamá, México, Brasil y Corea. Dicho estudio finalizó con la adopción del modelo de Corea del Sur, por ser lider mundial en esta temática (compras electrónicas); mediante su sistema de gestión denominado Korea On Line e-Procurement System (Koneps), definido como el 'marketplace' más grande del mundo. Este modelo, mencionan en información de SICOP [@sicop].\n\n# Webscraping SICOP\n\n## Carga de librerías y directorio de trabajo\n\nEl directorio de trabajo depende de donde se encuentre el archivo de trabajo.\n\n```{r}\n#| output: false\nsetwd(\"~/GitHub/R-Geografia-y-Data/posts/SICOP/\") # Directorio de trabajo\n\n# Paquetes a utilizar\n\nlibrary(RSelenium)\nlibrary(tidyverse)\nlibrary(rvest)\nlibrary(xml2)\nlibrary(stringi)\nlibrary(seleniumPipes)\nlibrary(XML)\nlibrary(knitr)\nlibrary(kableExtra)\n```\n\n## Inicio del server de selenium y el navegador\n\nEs posible elaborar un código para conocer cuales son las ofertas que se encuentran en etapa de recepción de ofertas en el SICOP. Dada la estructura de la página se utiliza la libreria [RSelenium](https://cran.r-project.org/web/packages/RSelenium/index.html) en lugar de [rvest](https://rvest.tidyverse.org). Esto dado que se trata de un sitio web interactivo.\n\nSe puede iniciar con la creación de un servidor para navegar.\n\n```{r}\n#| eval: false\n\n# Este script permite obtener los concursos de \n# municipalidades que se encuentran en la etapa de recepción de ofertas\n\n# Empezar el servidor\nrs_driver_object <- rsDriver(browser = 'chrome', # Se utilizará Google Chrome\n                             chromever = '108.0.5359.71', # Versión de Chrome\n                             verbose = FALSE, # No incluir mensajes de estado\n                             port = free_port(), # Se utiliza un puerto libre\n                             check = TRUE) # Checar si hay nuevas versiones\n```\n\nDespués de la creación del servidor, se puede crear un objeto cliente y se asigna a una variable. También se abre el navegador y la página web de SICOP.\n\n```{r}\n#| eval: false\n\n# crear un objeto cliente\nremDr <- rs_driver_object$client\n\n# Se navega a la página de interés\n\nremDr$navigate('https://www.sicop.go.cr/index.jsp') # \n\n```\n\nAl estar en la página web interesa irse a la sección de la misma en donde se encuentra la información de los concursos actuales. La página web principal de SICOP se conforma por dos frames. El botón para ir a los concursos de encuentra en el primer frame, para poder clickearlo es necesario hacerle énfasis al primer frame.\n\n```{r}\n#| eval: false\n\n# Se busca el identificador de los frames\n\nwebElems <- remDr$findElements(\"tag name\",\"frame\")\n\n# Se aprecian los enlaces de frames existentes\n\nsapply(webElems, function(x){x$getElementAttribute(\"src\")})\n\n\n```\n\nPodemos apreciar que existen dos frames, los cuales corresponden al \"top frame\" y al \"middle frame\". Esto también puede analizarse desde el código fuente de la página web, lo cual es permitido por algunos navegadores\n\n![Parte del código fuente donde se aprecia la estructura de la página](images/paste-A4394AA6.png){alt=\"Parte del código fuente donde se aprecia la estructura de la página\" fig-align=\"center\"}\n\nAl comprobar cual de los dos frames corresponde al frame donde se encuentra la opción para buscar los concursos, se selecciona el mismo (recordar que se guardaron los frames en la variable \"webElems\", entonces nada más se selecciona el frame de arriba o \"topFrame\")\n\nYa seleccionado el frame que nos interesa, es posible hacer click en sus elementos. En este caso se realiza click en la pestaña de concursos. Para ello se utiliza el \"xpath\" el cual se puede obtener con la opción de \"inspeccionar elemento\" que ofrecen algunos navegadores.\n\n```{r}\n#| eval: false\n\n# Se cambia al frame 1 (topFrame)\n\nremDr$switchToFrame(webElems[[1]])\n\n# Se busca el elemento de interés e inmediatamente se clickea el mismo\n\nremDr$findElement(\"xpath\", # Se especifica el método de búsqueda y se coloca el identificador\n                  \"/html/body/div[2]/div/div/div[4]/ul/li[2]/div[1]/a[3]\")$clickElement() # Se clickea\n```\n\nAl estar en la página donde se colocan los parámetros de búsqueda, es posible continuar. No obstante, recordar que hicimos enfoque a un frame específico de la página. De acuerdo a la documentación únicamente debemos utilizar la misma función pero asignarle \"NULL\" en el argumento; a pesar de estar en la documentación dicho método no funciona y es necesario colocar \"NA\" en lugar de \"NULL\" para regresar al frame principal.\n\n```{r}\n#| eval: false\n\nremDr$switchToFrame(NA) #\n\n# Se busca el identificador de los frames\n\nwebElems <- remDr$findElements(\"tag name\",\"frame\")\n\n# Se aprecian los enlaces de frames existentes\n\nsapply(webElems, function(x){x$getElementAttribute(\"src\")})\n\n\n```\n\nApreciamos nuevamente que existen dos frames, pero al analizar la estructura de la página, vemos que el frame con los parámetros para buscar se encuentran en el segundo frame. Para ello se selecciona el mainframe y en el mainframe se selecciona el rightframe.\n\nAdemás, se desea buscar todos los resultados que tengan \"Municipalidad\" en su texto. Para esto se busca y selecciona el cuadro donde se escribe y se coloca el texto.\n\n```{r}\n#| eval: false\n\nwebElems <- remDr$findElements(\"name\",\"mainFrame\")\nremDr$switchToFrame(webElems[[1]])\nwebElems2 <- remDr$findElements(\"name\",\"rightFrame\")\nremDr$switchToFrame(webElems2[[1]])\n\n# Se busca el identificador para la descripción de procedimiento\n\nDescProc <- remDr$findElement(\"name\", \"cartelNm\") \n\nDescProc$sendKeysToElement(list(\"Municipalidad\")) # Se escribe lo que interesa\n```\n\nSi se desea cambiar la fecha de búsqueda es posible realizarlo de la siguiente manera. Específicamente, se cambia la fecha de rangos de publicación, mientras que la fecha máxima usualmente corresponde al día en que se consulte.\n\n## Llenado de formularios\n\n```{r}\n#| eval: false\n\n# Cambiar fecha\n\ndd <- \"01\" # Día\nmm <- \"01\" # Mes\naa <- \"2010\" # Año\n\nstrdate <- paste0(dd,mm,aa) # deben ser de tipo string o si no se borran los ceros\n\n# Se encuentra el cuadro de fecha con el xpath\n\nfecha <- remDr$findElement(\"xpath\", '//*[@id=\"regDtFrom\"]')\n\nfecha$clickElement() # Se clickea la fecha\nfecha$clearElement() # Se borra la fecha que está puesta por default\nfecha$sendKeysToElement(list(strdate)) # Se escribe lo que interesa\n```\n\nEnseguida, se busca la opción de \"Estado del Concurso\" mediante su xpath, el cual se obtiene desde el navegador. Se selecciona la opción \"Todos\"\n\n```{r}\n#| eval: false\n\nremDr$findElement(\"xpath\",\"/html/body/div[1]/div/div[2]/form[1]/table/tbody/tr[12]/td/select/option[1]\")$clickElement() # Estado del concurso\n\n```\n\n## Obtención de información tabulada\n\nFinalmente, para realizar la búsqueda se realiza click al cuadro de \"consultar\" especificando mediante su \"xpath\"\n\n```{r}\n#| eval: false\n\n# Para consultar\n# Se hace una variable para con la consulta para facilitar el ejemplo\nConsultar <- remDr$findElement(\"xpath\", \"/html/body/div[1]/div/div[2]/p/span/a\") \nConsultar$clickElement() # Se hace click en consultar (por xpath)\n```\n\nAl realizar la búsqueda se aprecia que los contenidos se encuentran en una tabla y además existe una cantidad de páginas con más tablas. Si se desea obtener todo el contenido de todas las páginas entonces el objetivo es la obtención de todas las tablas por cada páginas.\n\nSin embargo para comprender como funciona la obtención de información, se puede realizar por pasos. Para obtener la primera tabla se puede realizar lo siguiente:\n\n```{r}\n#| eval: false\n\nread_html(remDr$getPageSource()[[1]]) %>% \n  html_nodes(xpath = \"/html/body/div[1]/div/div[2]/table[2]\") %>% \n  html_table(trim = T)\n\n```\n\nY al ejecutar el código se obtiene un resultado similar al siguiente:\n\n```{r}\n#| echo: false\n#| column: body-outset\nts <- read.csv(\"output/csv/tabla1.csv\",encoding = \"utf8\")\n#ts <- ts[,c(-1,-2,-4)]\nfor (i in 1:dim(ts)[2]) {\n  ts[,i] <- str_trim(ts[,i])\n}\nts <- ts[,c(-1,-2)]\n\n\nkbl(ts) %>%\n  kable_styling(bootstrap_options = \"striped\", full_width = F, position = \"left\")\n```\n\n::: callout-note\nUtilizar la barra de desplazamiento para lograr apreciar toda la tabla\n:::\n\n## Capturas de pantalla\n\nDicha tabla correspondería al contenido de tabla actual de la página web de SICOP. De igual forma puede realizarse un \"screenshot\" el contenido actual de la página de la siguiente manera:\n\n```{r}\n#| eval: false\n\n# Si usas esta opción, la pestaña se maximiza y el screnshot abarcará más área\n# remDr$maxWindowSize() \n\nremDr$screenshot(file = \"output/ss/SICOP_Municipalidad.png\") # Tomar screenshot\n```\n\nEl screenshot se vería de la siguiente forma:\n\n![](output/ss/SICOP_Municipalidad.png)\n\n# Obtención de datos detallados\n\nSegún la tarea que se realice, puede que interese la obtención de más detalles en la misma página web. En la página de SICOP, al dar click en alguno de las descripciones de procedimientos es posible obtener información más detallada de cada concurso. Mediante el lenguaje R y RSelenium es posible; para esto hay que obtener el xpath de la descripción que se desea clickear.\n\n```{r}\n#| eval: false\n\n# Se busca el xpath y se clickea\nremDr$findElement(\"xpath\", \"/html/body/div[1]/div/div[2]/table[2]/tbody/tr[2]/td[2]/a[1]\"\n                  )$clickElement()\n```\n\n```{r}\n#| eval: false\n\nhtml <- read_html(remDr$getPageSource()[[1]])\n\nread_html(remDr$getPageSource()[[1]]) %>% \n  html_nodes(xpath = \"/html/body/div/div/div[2]/table[3]\") %>% \n  html_table(trim = T)\n\n```\n\nEntonces, un método más adecuado sería la obtención de los nombres de columna y los contenidos de columna por separado. Esto es posible dado que cada nombre de columna posee un contenido de celda (es decir, no hay más de uno o de otro). Para esto se obtiene el xpath de la tabla de interés (ya que hay varias en la página web), se extrae el código fuente, se extraen los nombres de celda, los contenidos de celda y se asigna un identificador de columna para facilitar el pivot de la tabla.\n\nAl pasar la tabla a formato largo, se asignan los nombres de columna que fueron obtenidos\n\n```{r}\n#| eval: false\n\nhtml <- read_html(remDr$getPageSource()[[1]]) %>% \n  html_nodes(xpath = \"/html/body/div/div/div[2]/table[3]\")\n\nnomb.column <- html %>% # Para obtener nombre de columna\n  html_nodes(\"th.epcthl\") %>% # Nodo con el contenido\n  html_text() %>% # formato\n  str_trim(side = \"both\") %>% # limpieza\n  str_squish() %>% # remover espacios en blanco repetidos al interior del string\n  make.names() # Se vuelve texto valido para nombre de columna\n\ncontenido <- html %>% # Para obtener contenido\n  html_nodes(\"td.eptdl\") %>% # Nodo con el contenido\n  html_text() %>% \n  str_trim(side = \"both\") %>% # limpieza\n  str_squish() # remover espacios en blanco repetidos al interior del string\n```\n\nPara regresar a la página donde se encuentra el resto de concursos únicamente se debe especificar lo siguiente:\n\n```{r}\n#| eval: false\nremDr$goBack()\n```\n\nYa obtenidos los nombres de columna y contenidos se procede a dar estructura a la tabla. Se puede realizar de la siguiente manera:\n\n```{r}\n#| eval: false\n\n# Se realiza un dataframe en blanco con número de columnas igual\n# al largo del \"nomb.column\" que será los nombres de columna\ndf0 <- data.frame(matrix(ncol = length(nomb.column))) \n\ndf0[nrow(df0),] <- contenido # Se asigna la fila con el contenido\ncolnames(df0) <- nomb.column # Se asignan nombres de columna\n```\n\nEl resultado de la tabla obtenida debería ser similar a la siguiente (para facilitar la visualización únicamente se muestran 3 elementos de la tabla):\n\n```{r}\n#| echo: false\n#| column: body-outset\ndf <- read.csv(\"output/csv/tabla2_detalles.csv\")\ndf <- df[,c(8,16,17)]\nkbl(df) %>%\n  kable_styling(bootstrap_options = \"striped\", full_width = F, position = \"left\") %>% \n  column_spec(1, bold = T, border_right = T) %>%\n  column_spec(2, width = \"30em\")\n```\n\nLo que se realizó fue el webscrape de los elementos de la siguiente \"tabla\":\n\n![](images/image-1589146602.png)\n\n## Utilización de loops para obtener grandes volúmenes de información\n\nAl tener la estructura básica para obtener la información de una página web, es posible aplicar la misma fórmula para obtener grandes cantidades de información de la misma página web. Para esto es posible utilizar el loop `for`.\n\n```{r}\n#| eval: false\n\n# Ejemplo de utilización de un loop \"for\"\n\nfor (x in 1:10) { # Se brinda una secuencia la cual será seguida por la variable\n  print(x) # Se indica que devuelva el valor de la variable\n  # Al finalizar devolverá el siguiente valor que corresponde a la variable del loop\n}\n```\n\nEn el caso estudiado si se obtiene una secuencia que implique toda la información que se desea obtener, es posible aplicar dicho loop para obtener la misma. Para esto es necesario analizar un poco la estructura de la página.\n\nSe puede realizar de diferentes formas pero en este caso se buscará el patrón para cada nodo donde se clickea para obtener información específica del concurso. Al analizar la secuencia de concursos se aprecia lo siguiente:\n\n```{r}\n#| eval: false\n\n# xpath para el primer concurso de la página\n\"/html/body/div[1]/div/div[2]/table[2]/tbody/tr[2]/td[2]/a[1]\"\n\n# xpath para el último concurso de la página\n\"/html/body/div[1]/div/div[2]/table[2]/tbody/tr[11]/td[2]/a[1]\"\n```\n\nEl \"tr\\[x\\]\" aumenta en número según el concurso que corresponda. Asumiendo una página llena de concursos, tendríamos 10 concursos por página. No obstante si se desean obtener todos los concursos de todas las páginas, llegará el momento en que una de estas páginas no tendrá 10 concursos en la página; para evitar problemas con esto es posible buscar una condición que indique el número de concursos que hay por página.\n\nUn método para obtener la cantidad de concursos sería obtener la tabla de concursos y saber cuantos elementos hay en la misma. Para evitar el cambio entre frames, es posible utilizar el link directo al frame donde se encontrarían las tablas (este es un frame dentro del \"mainFrame\"). Este link puede obtenerse mediante el método utilizado en la explicación del cambio entre frames.\n\n```{r}\n#| eval: false\n\nremDr$switchToFrame(NA) # Si hay un frame enfocado, se quita el focus.\n\n# Se cambia al mainFrame\nremDr$switchToFrame(webElems[[1]]) # Se cambia al mainFrame\n\n# Se busca el identificador de los frames\nwebElems <- remDr$findElements(\"tag name\",\"frame\")\n\n# Se aprecian los enlaces de frames existentes, interesa el frame \"moduloOferta\"\n# Así que se guarda su valor en un string\nsapply(webElems, function(x){x$getElementAttribute(\"src\")})\n\nlink_tabla <- as.character(sapply(webElems, function(x){x$getElementAttribute(\"src\")})[2])\n```\n\nObtenido el frame mencionado, ya no es necesario cambiar constantemente entre frames y con esto es posible ahorrar el espacio del código que pudo ser usado para ello. Ahora es posible realizar la misma búsqueda como la realizada en la primera sección.\n\n```{r}\n#| eval: false\n\n# Se realiza lo mismo que se realizó al inicio\n# Pero en este caso no es necesario cambiar entre frames\n\nremDr$switchToFrame(NA) # Si hay un frame enfocado, se quita el focus.\n\n# Página de SICOP para buscar concursos\n\nremDr$navigate('https://www.sicop.go.cr/moduloOferta/search/EP_SEJ_COQ600.jsp')\n\n# Se busca el identificador para la descripción de procedimiento\n\nDescProc <- remDr$findElement(\"name\", \"cartelNm\") \n\nDescProc$sendKeysToElement(list(\"Municipalidad\")) # Se escribe lo que interesa\n\n# Cambiar fecha\n\ndd <- \"01\" # Día\nmm <- \"01\" # Mes\naa <- \"2010\" # Año\n\nstrdate <- paste0(dd,mm,aa) # deben ser de tipo string o si no se borran los ceros\n\n# Se encuentra el cuadro de fecha con el xpath\n\nfecha <- remDr$findElement(\"xpath\", '//*[@id=\"regDtFrom\"]')\n\nfecha$clickElement() # Se clickea la fecha\nfecha$clearElement() # Se borra la fecha que está puesta por default\nfecha$sendKeysToElement(list(strdate)) # Se escribe lo que interesa\n\nremDr$findElement(\"xpath\",\"/html/body/div[1]/div/div[2]/form[1]/table/tbody/tr[12]/td/select/option[1]\")$clickElement() # Estado del concurso\n\n# Para consultar\n# Se hace una variable para con la consulta para facilitar el ejemplo\nConsultar <- remDr$findElement(\"xpath\", \"/html/body/div[1]/div/div[2]/p/span/a\") \nConsultar$clickElement() # Se hace click en consultar (por xpath)\n\n```\n\nPara obtener el número de concursos para cada página es posible realizar lo siguiente:\n\n```{r}\n#| eval: false\n\nnum_pag <- read_html(remDr$getPageSource()[[1]]) %>% # se extrae numero de paginas\n  html_nodes(\"li a\") %>% # Se especifica lo que contiene el número de páginas\n  html_text() # se devuelve como texto\n\n# Se remueven los elementos en blanco\n\nnum_pag <- num_pag[num_pag != \"\"]\n```\n\nLuego se plantea el loop para obtener todas las tablas por cada página del set de páginas (de la página 1 a la página 10 únicamente).\n\n```{r}\n#| eval: false\n\nrm(\"df0\",\"df1\",\"i\",\"df2\")\n\n# Inicio del loop\n\nfor (i in num_pag) {\n\n# Si existe el df \"df0\" no se hace nada (se enseña un mensaje)\n# Si no existe se crea un df en blanco con x cantidad de columnas\n  \nifelse(exists(\"df0\"),paste0(\"Procesando página \",i,\"...\"),\n       assign(\"df0\",data.frame(matrix(ncol = length(1:5),nrow = 0))))\n  \n  # Se lee el código fuente, se busca el nodo con xpath, se extrae la tabla\n  # Y se pasa a un objeto data frame\n  \n  df1 <- read_html(remDr$getPageSource()[[1]]) %>% \n    html_nodes(xpath = \"/html/body/div[1]/div/div[2]/table[2]\") %>%\n    html_table() %>%\n    as.data.frame()\n\n  # Se asignan nombres de columna del df1 al df0\n  colnames(df0) <- colnames(df1)\n\n  # Se combina el df en blanco y el df con datos\n  df0 <- rbind(df0,df1) #\n\n  # Se crea una nueva variable dado que el número de página no corresponde al número\n  # para pasar de página según el xpath\n  jj <- as.numeric(i)-1\n\n  # Si el número de página es mayor a 2, entonces antes de pasar de página se volverá a\n  # la página 1 antes de ir a la siguiente página (esto dado que el xpath cambia\n  # según la página en que se encuentre)\n  if (i > 2) {\n    remDr$goBack # Ir hacia la página anterior\n    remDr$findElement(\"xpath\", # Ir a la siguiente página\n                      paste0('//*[@id=\"paging\"]/ul/li/a[',jj,']'))$clickElement() \n  } else{\n    remDr$findElement(\"xpath\", # Ir a la siguiente página\n                      paste0('//*[@id=\"paging\"]/ul/li/a[',jj,']'))$clickElement()\n  }\n  \n}\n```\n\nDespués de llegar al final del número de páginas que fueron obtenidas y almacenadas en la variable \"num_pag\", es posible seguir con el siguiente set de páginas. Para esto es posible indicar que cuanto se termine el loop de un set de páginas, se pase al siguiente set de páginas y se obtenga nuevamente el número de páginas para el nuevo set. Al revisar los xpath para pasar al siguiente set de páginas se obtiene lo siguiente:\\\n\n```{r}\n#| eval: false\n\n'//*[@id=\"paging\"]/ul/li/a[10]' # xpath para pasar al segundo set de páginas\n\n'//*[@id=\"paging\"]/ul/li/a[12]' # xpath para pasar el resto de set de páginas\n```\n\nExiste diferencia entre el xpath para pasar al segundo set de páginas y el que permite pasar el resto de set de páginas. Alternativamente, para evitar el uso de código adicional puede utilizarse un identificador de nombre en lugar de un xpath. El identificador de nombre para pasar de set de páginas en este caso es \"page02\" (se obtiene \"inspeccionando\" en el navegador). Entonces, pasar pasar cualquier set de páginas es posible realizar lo siguiente:\n\n```{r}\n#| eval: false\nremDr$findElement(\"class name\", \"page02\")$clickElement() # Click siguiente set de paginas\n```\n\nAdemás de pasar de páginas, para realizar el loop es necesario cuando debe detenerse el mismo. Para esto es posible determinar la cantidad de set de páginas de antemano. Entonces es posible obtener el xpath que indica la cantidad máxima de páginas de los concursos. A no ser que exista un cambio mientras se obtiene la información, no sería necesario que este paso se encuentre adentro del loop.\n\n```{r}\n#| eval: false\n\n# se extrae numero de paginas\n\ntot_pags <- read_html(remDr$getPageSource()[[1]]) %>% \n  # Se especifica lo que contiene el número de páginas\n  html_nodes(xpath = '//*[@id=\"total\"]/span[3]') %>% \n  html_text() %>% \n  # Se pasa a numérico\n  as.numeric()\n\ntot_pags\n```\n\nAhora se crea una variable que cambiará según la cantidad total de páginas. Esta ayudará a determinar cuando se detendrá el loop. Se divide entre 10 el número total de páginas y se divide hacia abajo el resultado; esto hará que al llegar a la última página, termine el loop\n\n```{r}\n#| eval: false\n\n# Se coloca nuevamente la asignación de esta variable para facilitar la comprensión de\n# donde proviene el \"set_pags\"\n\nset_pags <- ceiling(tot_pags/10) # Floor para redondear hacia arriba\nset_pags                         # Se visualiza el resultado\n```\n\nEntonces, ya se posee suficiente código para ensamblar el loop, excepto que se realizará el mismo obteniendo mayores detalles de cada concurso (lo cual se realizó anteriormente). El fin es rla obtención de los detalles de cada concurso pero a lo largo de todas las páginas y sets de páginas existentes para el momento de ejecución del código. Para ello existiría una jerarquía de loops, de mayor a menos: una que itere sobre los sets de páginas, otra que itere sobre los números de página de los sets de páginas y otra que itere sobre cada elemento de tabla de la página.\n\n```{r}\n#| eval: false\n\n\n# Se coloca el xpath en dos variables para que al concatenarlas\n# sea posible colocar en medio la variable de iteración\n\nxp1 <- \"/html/body/div[1]/div/div[2]/table[2]/tbody/tr[\"\nxp2 <- \"]/td[2]/a[1]\"\n```\n\nEntonces se procede a plantear el loop:\n\n```{r}\n#| eval: false\n#| warning: false\n\n# Loop para los sets de páginas\n\nfor (i in 1:set_pags) { \n  num_pag <- read_html(remDr$getPageSource()[[1]]) %>%\n    html_nodes(\"li a\") %>% \n    html_text()\n  num_pag <- num_pag[num_pag != \"\"]\n  num_pag <- length(num_pag)+1\n\n  # Loop para las páginas de un set\n\n  for (ii in 1:(max(num_pag))) { \n  \n    # Si el número de iteración es mayor a 1 entonces\n    # se pasará la página\n  \n    if (ii > 1){\n      remDr$findElement(\"xpath\",\n      paste0('//*[@id=\"paging\"]/ul/li/a[',ij,']'))$clickElement()\n    }\n  \n    # Se determina el número de concursos que tiene la tabla\n    # para la determinada página\n  \n    nrow_tab <- read_html(remDr$getPageSource()[[1]]) %>% \n      html_nodes(xpath = \"/html/body/div[1]/div/div[2]/table[2]\") %>%\n      html_table() %>%\n      as.data.frame() %>% \n      nrow() \n  \n    # Loop para los rows\n  \n    for (j in 1:nrow_tab) { \n      print(paste0(\"Scrapeando contenido del concurso \",j))\n      jj <- as.numeric(j) + 1\n      \n      # Se clickea en el elemento j de la tabla\n      \n      remDr$findElement(\"xpath\", paste0(xp1,jj,xp2))$clickElement()\n      \n      # Se obtiene el código y se guarda en una variable\n      \n      html <- read_html(remDr$getPageSource()[[1]]) %>% \n        html_nodes(xpath = \"/html/body/div/div/div[2]/table[3]\")\n      \n      # Se obtienen los nombres de columna\n      \n      nomb.column <- html %>%\n        html_nodes(\"th.epcthl\") %>%\n        html_text() %>% \n        str_trim(side = \"both\") %>%\n        str_squish() %>% \n        make.names()\n       \n      # Se obtiene el contenido\n        \n      contenido <- html %>% \n        html_nodes(\"td.eptdl\") %>%\n        html_text() %>% \n        str_trim(side = \"both\") %>% \n        str_squish()\n      \n      # Se realiza un df en blanco del largo de nomb.column\n      \n      assign(\"df0\",data.frame(matrix(ncol = length(nomb.column))))\n      \n      # Se asignan los nombres de columna\n      # Se asigna el contenido al df\n\n      colnames(df0) <- nomb.column\n      df0[nrow(df0),] <- contenido\n\n      # Si existe \"df_concursos\" se le agrega df0\n      # si no existe, df0 será df_concursos\n      \n      ifelse(exists(\"df_concursos\"),\n             assign(\"df_concursos\",bind_rows(df0, df_concursos)),\n             assign(\"df_concursos\", df0))\n      \n      # Se remueven las variables innecesarias\n      \n      rm(df0,nomb.column,contenido,html)\n      \n      # Se vuelve a la página anterior\n      \n      remDr$goBack()\n    }\n  \n    # Si el set de páginas es mayor a 1 el numero para hacer click en xpath\n    # cambia y aumenta de 1 (en el primer set es 1 para la pagina 2) a 3 y\n    # por esta razón después de que el set de páginas es mayor a 1, se suma 2\n\n    if (i > 1) { \n      ij <- ii+2\n      } else{\n      ij <- ii\n      }\n  }\n\n# Si i (set de páginas) es igual a \"set_pags\" entonces\n# el webscrape terminó. De lo contrario dará click\n# en el siguiente set de páginas\n\nif (i == set_pags) {\n  print(\"Webscrape terminado\")\n  } else{\n\n    # Para pasar el set de    \n    remDr$findElement(\"class name\", \"page02\")$clickElement() \n  }\n}\n```\n\nEl resultado es un data frame con los detalles de los concursos publicados en SICOP que están relacionados con la palabra \"Municipalidad\" y que aun se encuentran o no en recepción de ofertas. La tabla debería lucir similar a la siguiente:\n\n```{r}\n#| echo: false\n#| column: screen-inset\ndf <- read.csv(\"output/csv/ConcursosSICOP.csv\")\ndf <- df[,-1]\ndf <- head(df)\nrmarkdown::paged_table(df)\n\n```\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"toc-depth":3,"output-file":"index.html"},"language":{},"metadata":{"lang":"es","fig-responsive":true,"quarto-version":"1.2.269","editor":"visual","theme":"cyborg","toc-title":"Contenidos","toc-location":"left","title-block-banner":true,"title":"Webscraping básico con RSelenium","author":"Gabriel Ramírez","date":"12/23/2022","csl":"apa.csl","bibliography":["references.bib"],"categories":["Webscraping","RSelenium","analysis"],"image":"image.jpg"},"extensions":{"book":{"multiFile":true}}}}}