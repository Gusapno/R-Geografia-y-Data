{
  "hash": "8fafbe48f50b7ddfdd833fc010a2cdeb",
  "result": {
    "markdown": "---\ntitle: \"Limpieza de datos scrapeados con R\"\nexecute:\n  warning: false\nauthor: \"Gabriel Ramírez\"\ndate: \"12/23/2022\"\nlang: es\neditor: visual\ncsl: apa.csl\nbibliography: references.bib\ncategories: [Webscraping, RSelenium, limpieza de datos]\nimage: \"image.jpg\"\n---\n\n\n# Sobre la limpieza y preparación de datos\n\nLa limpieza y/o preparación de datos es una parte esencial del análisis estadístico. Usualmente esto toma más tiempo que el análisis estadístico como tal; usualmente en los ejercicios y ejemplos de análisis estadísticos se asume que los datos tienen una estructura adecuada para el análisis pero en la práctica suele ser necesario preparar el set de datos antes de realizar un análisis a los mismos [@datacleaningR].\n\nUn set de datos técnicamente correcto se entiende como uno en el que cada valor: se puede reconocer que pertenece a cierta variable, es almacenado en un tipo de dato que representa el dominio de valores de la variable en la vida real; es decir, para cada tipo de valor, su variable debe pertenecer a su tipo adecuado (una de texto a una de texto, una numérica a una numérica, etc...). @datacleaningR define un set de datos técnicamente correcto como un set en el que: es almacenada en un `data.frame` con columnas adecuadas y cada columna del `data.frame` es de un tipo que representa adecuadamente el dominio de valores de su variable.\n\nEl contenido de un set de datos podría ser no consistente, lo cual puede devenir en errores de análisis. Entre los posibles errores se encuentra el hecho de escribir la misma palabra de formas diferentes, la codificación del texto (por ejemplo, UTF-8), valores faltantes, outliers, valores especiales e incluso espacios en blanco innecesarios en una palabra o oración.\n\nPara lograr la consistencia en la data es posible: detectar las inconsistencias, seleccionar los campos que causan las inconsistencias y la corrección de estos campos ya sea mediante métodos determinísticos (modelos) o estocásticos.\n\n# Búsqueda de inconsistencias\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Directorio de trabajo\nsetwd(\"~/GitHub/R-Geografia-y-Data/posts/SICOP_Limpieza\")\n\n# Paquetes a utilizar\nlibrary(tidyverse)\nlibrary(knitr)\nlibrary(reshape2)\nlibrary(magrittr)\nlibrary(kableExtra)\nlibrary(stringi)\nlibrary(scraEP) # Para remover acentos\nlibrary(gsubfn)\n# Datos a utilizar\ndata <- read.csv(\"csv/ConcursosSICOP.csv\")\ndata <- data[,-1]\n```\n:::\n\n\nUna forma básica de conocer la estructura básica del set de datos es utilizar `str()`, aunque en este caso se utiliza un método diferente para facilitar la visualización de la estructura de los datos.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr <- data.frame(variable = names(data),\n           classe = sapply(data, typeof),\n           first_values = sapply(data, function(x) paste0(head(x),  collapse = \", \")),\n           row.names = NULL)\ncolnames(str) <- c(\"Columna\",\"Tipo\",\"Primeros valores\")\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped\" style=\"font-size: 14px; \">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Columna </th>\n   <th style=\"text-align:left;\"> Tipo </th>\n   <th style=\"text-align:left;\"> Primeros valores </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> 22 </td>\n   <td style=\"text-align:left;\"> Cierre.de.recepción.de.ofertas </td>\n   <td style=\"text-align:left;\"> character </td>\n   <td style=\"text-align:left;\"> 08/08/2022 10:00, 31/08/2022 15:00, 03/08/2022 08:45, 27/07/2022 09:00, 30/08/2022 17:00, 28/07/2022 10:00 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 23 </td>\n   <td style=\"text-align:left;\"> Fecha.hora.de.apertura.de.ofertas </td>\n   <td style=\"text-align:left;\"> character </td>\n   <td style=\"text-align:left;\"> 08/08/2022 10:00, 31/08/2022 15:00, 03/08/2022 09:00, 27/07/2022 09:00, 30/08/2022 17:10, 28/07/2022 10:00 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 24 </td>\n   <td style=\"text-align:left;\"> Plazo.del.acto.final </td>\n   <td style=\"text-align:left;\"> character </td>\n   <td style=\"text-align:left;\"> 60 Días hábiles, 20 Días hábiles, 24 Días hábiles, 20 Días hábiles, 53 Días hábiles, 6 Días hábiles </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 25 </td>\n   <td style=\"text-align:left;\"> Presupuesto.total.estimado </td>\n   <td style=\"text-align:left;\"> character </td>\n   <td style=\"text-align:left;\"> 283.767,29 [CRC], 17.746.000 [CRC], 24.000.000 [CRC], 1.000.000 [CRC], 163.797.963,12 [CRC], 405.000 [CRC] </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 26 </td>\n   <td style=\"text-align:left;\"> Presupuesto.total.estimado.USD..Opcional. </td>\n   <td style=\"text-align:left;\"> character </td>\n   <td style=\"text-align:left;\"> , , , , 241.419 [USD], </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 27 </td>\n   <td style=\"text-align:left;\"> Fundamento.jurídico </td>\n   <td style=\"text-align:left;\"> character </td>\n   <td style=\"text-align:left;\"> NA, NA, NA, NA, NA, Contratación directa por escasa cuantía (art.2 inc. h) LCA y art. 144 RLCA) </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n::: callout-note\n## Nota sobre la tabla\n\nÚnicamente se muestran algunos valores de la tabla para facilitar la lectura.\n:::\n\nEn este caso se aprecia que los formatos de variable no corresponden necesariamente a un tipo adecuado para el análisis. Las fechas y el presupuesto poseen formato de tipo `character`, cuando el formato adecuado sería fecha (`date`) y numérico (`double`) respectivamente.\n\nTambién es posible buscar los valores únicos en columnas de interés, así como en el Estado del Concurso y Nombre de la institución.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunique.estado <- as.data.frame(sort(unique(data$Estado.del.concurso)))\nunique.estado$id <- seq(1:dim(unique.estado)[1])\ncolnames(unique.estado) <- c(\"Estado del concurso\",\"id\")\n\n# sort(unique(data$Nombre.de.la.institución))\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped\" style=\"font-size: 14px; \">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Estado del concurso </th>\n   <th style=\"text-align:right;\"> id </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\">  </td>\n   <td style=\"text-align:right;\"> 1 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Adjudicación en firme </td>\n   <td style=\"text-align:right;\"> 2 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Adjudicado </td>\n   <td style=\"text-align:right;\"> 3 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Apelación o Revocación </td>\n   <td style=\"text-align:right;\"> 4 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Contrato </td>\n   <td style=\"text-align:right;\"> 5 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Desierto/Infructuoso </td>\n   <td style=\"text-align:right;\"> 6 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> En apertura </td>\n   <td style=\"text-align:right;\"> 7 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> En evaluación </td>\n   <td style=\"text-align:right;\"> 8 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> En recepción de ofertas </td>\n   <td style=\"text-align:right;\"> 9 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Nulidad absoluta </td>\n   <td style=\"text-align:right;\"> 10 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Objetado </td>\n   <td style=\"text-align:right;\"> 11 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Publicado </td>\n   <td style=\"text-align:right;\"> 12 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nEn el caso de la columna con el estado del concurso la estructura parece ser consistente por lo tanto no será necesario realizar algún tiempo de limpieza o preparación. Se visualizan los primeros y los últimos 5 elementos (de en total 70 elementos).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunique.institucion <- as.data.frame(sort(unique(data$Nombre.de.la.institución)))\nunique.institucion$id <- seq(1:dim(unique.institucion)[1])\ncolnames(unique.institucion) <- c(\"Nombre de la institución\",\"id\")\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped\" style=\"font-size: 14px; \">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">   </th>\n   <th style=\"text-align:left;\"> Nombre de la institución </th>\n   <th style=\"text-align:right;\"> id </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> 1 </td>\n   <td style=\"text-align:left;\"> Instituto Costarricense de Puertos del Pacífico </td>\n   <td style=\"text-align:right;\"> 1 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 2 </td>\n   <td style=\"text-align:left;\"> INSTITUTO DE FOMENTO Y ASESORIA MUNICIPAL </td>\n   <td style=\"text-align:right;\"> 2 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 3 </td>\n   <td style=\"text-align:left;\"> MUNICIPALIDAD DE ACOSTA </td>\n   <td style=\"text-align:right;\"> 3 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 4 </td>\n   <td style=\"text-align:left;\"> Municipalidad de Alajuela </td>\n   <td style=\"text-align:right;\"> 4 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 5 </td>\n   <td style=\"text-align:left;\"> MUNICIPALIDAD DE ALVARADO DE PACAYAS </td>\n   <td style=\"text-align:right;\"> 5 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 65 </td>\n   <td style=\"text-align:left;\"> MUNICIPALIDAD DE TURRIALBA </td>\n   <td style=\"text-align:right;\"> 65 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 66 </td>\n   <td style=\"text-align:left;\"> Municipalidad de Turrubares </td>\n   <td style=\"text-align:right;\"> 66 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 67 </td>\n   <td style=\"text-align:left;\"> MUNICIPALIDAD DE UPALA </td>\n   <td style=\"text-align:right;\"> 67 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 68 </td>\n   <td style=\"text-align:left;\"> Municipalidad de Zarcero </td>\n   <td style=\"text-align:right;\"> 68 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 69 </td>\n   <td style=\"text-align:left;\"> Municipalidad del Cantón de Flores </td>\n   <td style=\"text-align:right;\"> 69 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 70 </td>\n   <td style=\"text-align:left;\"> Unión Nacional de Gobiernos Locales </td>\n   <td style=\"text-align:right;\"> 70 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nSe aprecia que hay elementos que no corresponden a una Municipalidad y también inconsistencias en la forma de escribir las nombres de cada Municipalidad (uso de mayúsculas). Para eliminar los elementos que no corresponden a una Municipalidad, se buscan todos los elementos que empiezan con `\"M\"` . Esto se realiza después de revisar los contenidos de la tabla y confirmar que todos los elementos que comienzan con `\"M\"` son municipalidades.\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- startsWith(unique.institucion$`Nombre de la institución`, \"M\")\nunique.institucion$value <- a\n\ndata_filtrado <- data %>% # Se selecciona el set de datos\n  filter(str_detect(Nombre.de.la.institución, \"(?i)^m\")) # Se filtra por letra inicial\nrm(a,data)\n```\n:::\n\n\nCon esto se obtienen los valores que inician con `M`. Además se agrega una columna para visualizar y filtrar rápidamente cuales son esos valores que no inician con `M`. En este caso se trata de:\n\n-   Instituto Costarricense de Puertos del Pacífico\n\n-   INSTITUTO DE FOMENTO Y ASESORIA MUNICIPAL\n\n-   Unión Nacional de Gobiernos Locales\n\nDado que no entran en el análisis de interés, se descartan completamente del set de datos.\n\n## Manipulación de carácteres y normalización\n\nDadas que las personas pueden escribir las mismas cosas de formas diferentes, los datos de tipo `carácter/character` se pueden volver complicados de procesar. Esto también incluye la posibilidad de espacios en blanco innecesarios (al inicio, entre o al final de las palabras). Este proceso se realiza en\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#| echo: false\n\n# Se renombra el encargado de publicación de gestión de objerciones y apertura\n# por un nombre corto\ncolnames(data_filtrado)[9] <- \"Enc.Pub.Gest.Apertu\" \n\n# Se renombra el encargado de solicitar estudio de ofertas recomendación del acto final\n# por un nombre corto\n\ncolnames(data_filtrado)[11] <- \"Enc.Solic.Est.Ofert\" \n\n\n# Se remueve texto innecesario (se identificó observando el set de datos)\ndata_filtrado$Nombre.de.la.institución <- str_remove(data_filtrado$Nombre.de.la.institución, \"(?i)Cantón de\")\n\n# Se sustituyen los \"del\" por \"de\" para facilitar la creación del regex\ndata_filtrado$Nombre.de.la.institución <- str_replace_all(data_filtrado$Nombre.de.la.institución,\"del\",\"de\")\n\n# Se separa en dos columna\ndata_filtrado <- data_filtrado %>% separate(Nombre.de.la.institución,\n                                            c(\"Institución\",\"Nombre\")\n                                            ,sep = \"(?i)\\\\A^.*?(?<!de).*?\\\\Kde\")\n# Se limpian los espacios en blanco\ndata_filtrado$Nombre <- str_trim(data_filtrado$Nombre,side = \"both\") \n\n# Se aplica limpieza sobre esas columnas\n# Se pasa a formato de titulo y se corrigen ciertos elementos\nfor (i in 10:12) {\ndata_filtrado[,i] <- str_to_title(data_filtrado[,i])\ndata_filtrado[,i] <- str_replace_all(data_filtrado[,i],'\\\\b(De)\\\\b',\"de\")\ndata_filtrado[,i] <- str_replace_all(data_filtrado[,i],'\\\\b(Los)\\\\b',\"los\")\n}\n\n# Se pasa a formato de título y se pasa a minúscula el \"De\" resultante\ndata_filtrado$Institución <- str_to_title(data_filtrado$Institución)\ndata_filtrado$Nombre <- str_to_title(data_filtrado$Nombre)\ndata_filtrado$Nombre <- str_replace_all(data_filtrado$Nombre,'\\\\b(De)\\\\b',\"de\")\n\n# data_filtrado <- respaldo\nrespaldo <- data_filtrado\n\n# Se pasa a formato de oración diversas columnas\nfor (i in 17:19) {\ndata_filtrado[,i] <- str_to_sentence(data_filtrado[,i])\n}\ndata_filtrado$Enc.Solic.Est.Ofert <- str_to_sentence(data_filtrado$Enc.Solic.Est.Ofert)\n\n# \ndata_filtrado$Nombre <- str_replace_all(data_filtrado$Nombre,\" de Heredia\",\"\")\ndata_filtrado$Nombre <- str_replace_all(data_filtrado$Nombre,\" de Pacayas\",\"\")\n```\n:::\n\n\n# Búsqueda y localización de errores\n\nSe analiza la consistencia del texto de algunas columnas de interés. Esto con el fin de encontrar y localizar posibles errores. Para esto se utiliza la función `unique()` para conocer los valores únicos de cada columna, con lo cual es posible conocer si existe alguna inconsistencia.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Se escriben y concatenan los nombres de las columnas de interés\n# Se excluye una de ellas para visualizar mejor el resultado\n\nnombres <- c(\"Estado.del.concurso\",\"Clasificación.del.objeto\",\n             \"Tipo.de.procedimiento\",\"Tipo.de.modalidad\") #,\"Fundamento.jurídico\")\n\n# Se realiza bucle para aplicar la misma función a las columnas seleccionadas\nfor (i in 1:length(nombres)) {\n  message(paste0(\"Resultados para la columna llamada \",nombres[i],\"...\"))\n  a <- paste0(\"data_filtrado$\",nombres[i])\n  print(unique(eval(parse(text = a))))\n\n}\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nResultados para la columna llamada Estado.del.concurso...\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"En evaluación\"           \"Adjudicación en firme\"  \n [3] \"Contrato\"                \"Desierto/Infructuoso\"   \n [5] \"\"                        \"Adjudicado\"             \n [7] \"Apelación o Revocación\"  \"En apertura\"            \n [9] \"Nulidad absoluta\"        \"En recepción de ofertas\"\n[11] \"Objetado\"                \"Publicado\"              \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nResultados para la columna llamada Clasificación.del.objeto...\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Bienes\"           \"Servicios\"        \"Bienes/servicios\" \"Obra publica\"    \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nResultados para la columna llamada Tipo.de.procedimiento...\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Licitación pública nacional\" \"Licitación abreviada\"       \n[3] \"Contratación directa\"        \"Contratación especial\"      \n[5] \"Remate\"                      \"Licitación reducida\"        \n[7] \"Licitación menor\"           \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nResultados para la columna llamada Tipo.de.modalidad...\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Según demanda\"                                       \n[2] \"Servicios\"                                           \n[3] \"Cantidad definida\"                                   \n[4] \"Arrendamiento de inmuebles sin opción de compra\"     \n[5] NA                                                    \n[6] \"Remate para dar en arrendamiento bienes inmuebles\"   \n[7] \"Arrendamiento de bienes muebles sin opción de compra\"\n```\n:::\n:::\n\n\nSe aprecia que existe una consistencia mínima (no se repiten valores que tienen el mismo significado) en los valores de las columnas, por lo tanto no es necesario aplicar una limpieza a las mismas.\n\n## Conversiones de tipos\n\nPara la búsqueda y localización de errores es posible revisar las columnas de interés. Esto con tal de buscar y localizar posibles errores que afecten la consistencia de los datos. Antes de ello, es posible descartar algunas columnas que no ofrecen ningún tipo de información.\n\n\n::: {.cell}\n\n:::\n\n\n# Códigos de cantón\n\nPara facilitar un posible análisis espacial es necesario añadir los códigos de cantón. Para esto se extraen los códigos de cantón del límite cantonal 1:5000 (obtenido del SNIT). Para facilitar el proceso se remueven las tildes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(gsubfn)\ncant.sf <- st_read(\"sp/LimCant5K.shp\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `LimCant5K' from data source \n  `C:\\Users\\gusan\\Documents\\GitHub\\R-Geografia-y-Data\\posts\\SICOP_Limpieza\\sp\\LimCant5K.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 82 features and 9 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 156152 ymin: 608833.8 xmax: 658879.5 ymax: 1241118\nProjected CRS: CR05 / CRTM05\n```\n:::\n\n```{.r .cell-code}\ncant_nombres <- as.data.frame(cant.sf[,3:4])\ncant_nombres <- cant_nombres[order(cant_nombres$cod_canton),]\n\nunwanted_array <- list('Š'='S', 'š'='s', 'Ž'='Z', 'ž'='z', 'À'='A', 'Á'='A', 'Â'='A','Ã'='A', 'Ä'='A', 'Å'='A', 'Æ'='A', 'Ç'='C', 'È'='E', 'É'='E','Ê'='E', 'Ë'='E', 'Ì'='I', 'Í'='I', 'Î'='I', 'Ï'='I', 'Ò'='O', 'Ó'='O', 'Ô'='O', 'Õ'='O', 'Ö'='O', 'Ø'='O', 'Ù'='U','Ú'='U', 'Û'='U', 'Ü'='U', 'Ý'='Y', 'Þ'='B', 'ß'='Ss', 'à'='a', 'á'='a', 'â'='a', 'ã'='a','ä'='a','å'='a', 'æ'='a', 'ç'='c','è'='e', 'é'='e', 'ê'='e', 'ë'='e','ì'='i','í'='i', 'î'='i', 'ï'='i', 'ð'='o', 'ò'='o', 'ó'='o', 'ô'='o', 'õ'='o','ö'='o', 'ø'='o', 'ù'='u', 'ú'='u', 'û'='u', 'ý'='y', 'ý'='y', 'þ'='b', 'ÿ'='y' ) # Lista de acentos y sus equivalentes sin acento\n\ncant_nombres$canton <- gsubfn(paste(names(unwanted_array),collapse='|'), \n                      unwanted_array,cant_nombres$canton)\ndata_filtrado$Nombre <- gsubfn(paste(names(unwanted_array),collapse='|'), \n                               unwanted_array,data_filtrado$Nombre)\n\ndata_filtrado$Nombre <- str_replace_all(data_filtrado$Nombre,\"Leon Cortes\",\n                                        \"Leon Cortes Castro\")\n\ndata_filtrado$Nombre <- str_replace_all(data_filtrado$Nombre,\"\\\\.\",\"\")\n\nrm(unwanted_array)\n```\n:::\n\n\nAhora lo que se desea, es agregar una columna con los códigos de cantón para facilitar la representación espacial de los datos. Para esto se utiliza un loop para agregar valores para cada fila de la columna basado en los valores del nombre de cantón\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_filtrado$cant_cod <- \"\"\n\n\nfor (i in 1:length(data_filtrado$Nombre)) {\n  # Se busca el nombre de cantón en la columna nombre, fila i\n  check <- data_filtrado$Nombre[i]\n  \n  # Se busca el nombre de cantón en la tabla de cant_nombres y su fila\n  check2 <- which(cant_nombres$canton == check)\n  \n  # Se guarda el código de cantón en una variable\n  cod <- cant_nombres[check2,1]\n  \n  # Se agrega el número de cantón a data_filtrado\n  data_filtrado$cant_cod[i] <- cod\n  \n  # Se remueve la variable con el código\n  rm(cod)\n}\n\n# Exportar la tabla\nwrite.csv(data_filtrado,\"output/csv/TablaLimpiaSICOP.csv\")\n```\n:::\n\n\nCon estos estos códigos de cantón se facilita la representación espacial de los datos. Además de esto es posible cambiar de formato largo a formato ancho. Un formato ancho (wide format) posee valores que no se repiten en la columna de nombres, mientras que en un formato largo se repiten valores en la columna de nombres (por ejemplo, se repiten nombres de cantón).\n\n-   Primero se pasa a formato ancho para facilitar la visualización en mapa\n\n-   Dentro de la aplicación, hacer referencia a la tabla con el nombre de cantón para referirse a la tabla original\n\n\n# Retoques adicionales a la tabla limpia\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.sicop <- read.csv(\"output/csv/TablaLimpiaSICOP.csv\",fileEncoding = \"windows-1252\")\n\ndata.sicop <- data.sicop[,-c(1,4,6,7,9,10:13,20,21)]\n\ndata.sicop[c(1,8:10)][data.sicop[c(1,8:10)] == ''] <- \"Sin definir\"\ndata.sicop[, c(1,8:10)][is.na(data.sicop[, c(1,8:10)])] <- \"Sin definir\"\n\ndata.sicop$Clasificación.del.objeto <- str_replace_all(data_filtrado$Clasificación.del.objeto,\"Obra publica\", \"Obra pública\")\n\nwrite.csv(data.sicop,\"output/csv/TablaLimpiaSICOP_reducida_2.csv\")\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../site_libs/kePrint-0.0.1/kePrint.js\"></script>\r\n<link href=\"../../site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}