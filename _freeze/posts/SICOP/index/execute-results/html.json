{
  "hash": "1791707cfeaf35fbada914eda408a59f",
  "result": {
    "markdown": "---\ntitle: \"Webscraping básico con RSelenium\"\nexecute:\n  warning: false\nauthor: \"Gabriel Ramírez\"\ndate: \"12/23/2022\"\nlang: es\neditor: visual\ncsl: apa.csl\nbibliography: references.bib\ncategories: [Webscraping, RSelenium, analysis]\nimage: \"image.jpg\"\n---\n\n\n# Contexto de SICOP\n\nEn este proyecto se obtienen datos del Sistema Integrado de Compras Públicas ([SICOP](https://www.sicop.go.cr/index.jsp)) por municipalidad. El fin es realizar un análisis descriptivo y espacializar los datos por municipalidad o institución (cantón o localización de municipalidad).\n\nEste sistema se autodenomina como una novedosa herramienta para la realización de negocios vía web. De forma más específica, permite a las proveedurías del Estado realizar compra y venta de servicios y productos de forma electrónica.\n\nEste modelo de compras se realizó tras un análisis de prácticas efectuadas por países como Chile, Panamá, México, Brasil y Corea. Dicho estudio finalizó con la adopción del modelo de Corea del Sur, por ser lider mundial en esta temática (compras electrónicas); mediante su sistema de gestión denominado Korea On Line e-Procurement System (Koneps), definido como el 'marketplace' más grande del mundo. Este modelo, mencionan en información de SICOP [@sicop].\n\n# Webscraping SICOP\n\n## Carga de librerías y directorio de trabajo\n\nEl directorio de trabajo depende de donde se encuentre el archivo de trabajo.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetwd(\"~/GitHub/R-Geografia-y-Data/posts/SICOP/\") # Directorio de trabajo\n\n# Paquetes a utilizar\n\nlibrary(RSelenium)\nlibrary(tidyverse)\nlibrary(rvest)\nlibrary(xml2)\nlibrary(stringi)\nlibrary(seleniumPipes)\nlibrary(XML)\nlibrary(knitr)\nlibrary(kableExtra)\nlibrary(netstat) # Para el free_port()\n```\n:::\n\n\n## Inicio del server de selenium y el navegador\n\nEs posible elaborar un código para conocer cuales son las ofertas que se encuentran en etapa de recepción de ofertas en el SICOP. Dada la estructura de la página se utiliza la libreria [RSelenium](https://cran.r-project.org/web/packages/RSelenium/index.html) en lugar de [rvest](https://rvest.tidyverse.org). Esto dado que se trata de un sitio web interactivo.\n\nSe puede iniciar con la creación de un servidor para navegar.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Este script permite obtener los concursos de \n# municipalidades que se encuentran en la etapa de recepción de ofertas\n\n# Empezar el servidor\nrs_driver_object <- rsDriver(browser = 'chrome', # Se utilizará Google Chrome\n                             chromever = '108.0.5359.71', # Versión de Chrome\n                             verbose = FALSE, # No incluir mensajes de estado\n                             port = free_port(), # Se utiliza un puerto libre\n                             check = TRUE) # Checar si hay nuevas versiones\n```\n:::\n\n\nDespués de la creación del servidor, se puede crear un objeto cliente y se asigna a una variable. También se abre el navegador y la página web de SICOP.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# crear un objeto cliente\nremDr <- rs_driver_object$client\n\n# Se navega a la página de interés\n\nremDr$navigate('https://www.sicop.go.cr/index.jsp') # \n```\n:::\n\n\nAl estar en la página web interesa irse a la sección de la misma en donde se encuentra la información de los concursos actuales. La página web principal de SICOP se conforma por dos frames. Esto se sabe dado que al inspeccionar el código fuente de la página, se aprecia lo siguiente:\n\n``` html\n</head>\n    <frameset rows=\"125,*\" cols=\"*\"  onunload=\"javascript:confirmClose();\" >\n        <frame src=\"/portal/fm/PT_FMJ_TFQ001.jsp?user_cls=\" frameborder=\"0\"  name=\"topFrame\" id=\"topFrame\"  scrolling=\"no\" noresize>\n        <frame src=\"/portal/fm/PT_FMJ_MFQ001.jsp?user_cls=\" frameborder=\"0\"  name=\"mainFrame\" id=\"mainFrame\" scrolling=\"yes\">\n    </frameset>\n</html>\n```\n\nEntonces, al conocer que el botón para la consulta de los concursos se encuentra en el primer frame, para poder clickearlo sería necesario hacerle énfasis al mismo. Para ello es posible extraer mediante `tag name` todos los elementos que coincidan con la palabra `frame`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Se busca el identificador de los frames\n\nwebElems <- remDr$findElements(\"tag name\",\"frame\")\n\n# Se aprecian los enlaces de frames existentes\n\nsapply(webElems, function(x){x$getElementAttribute(\"src\")})\n```\n:::\n\n\nAl obtener todos los elementos con `tag name` de nombre `frame` podemos apreciar que existen dos frames, los cuales corresponden al `topFrame` y al `middleFrame`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"https://www.sicop.go.cr/portal/fm/PT_FMJ_TFQ001.jsp?user_cls=\"\n\"https://www.sicop.go.cr/portal/fm/PT_FMJ_MFQ001.jsp?user_cls=\"\n```\n:::\n\n\nAl comprobar cual de los dos frames corresponde al frame donde se encuentra la opción para buscar los concursos, se selecciona el mismo (recordar que se guardaron los frames en la variable `webElems`, entonces nada más se selecciona el frame de arriba o `topFrame`)\n\nYa seleccionado el frame que nos interesa, es posible hacer click en sus elementos. En este caso se realiza click en la pestaña de concursos. Para ello se utiliza el `xpath` el cual se puede obtener con la opción de \"inspeccionar elemento\" que ofrecen algunos navegadores.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Se cambia al frame 1 (topFrame)\n\nremDr$switchToFrame(webElems[[1]])\n\n# Se busca el elemento de interés e inmediatamente se clickea el mismo\n# Se especifica el método de búsqueda y se coloca el identificador\n# luego se indica dar click en el elemento\n\nremDr$findElement(\"xpath\", \n                  \"/html/body/div[2]/div/div/div[4]/ul/li[2]/div[1]/a[3]\")$clickElement()\n```\n:::\n\n\nAl estar en la página donde se colocan los parámetros de búsqueda, es posible continuar. No obstante, recordar que hicimos enfoque a un frame específico de la página. De acuerdo a la documentación únicamente debemos utilizar la misma función pero asignarle `NULL` en el argumento; a pesar de estar en la documentación dicho método no funciona y es necesario colocar `NA` en lugar de `NULL` para regresar al frame principal.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nremDr$switchToFrame(NA) #\n\n# Se busca el identificador de los frames\n\nwebElems <- remDr$findElements(\"tag name\",\"frame\")\n\n# Se aprecian los enlaces de frames existentes\n\nsapply(webElems, function(x){x$getElementAttribute(\"src\")})\n```\n:::\n\n\nApreciamos nuevamente que existen dos frames, pero al analizar la estructura de la página, vemos que el frame con los parámetros para buscar se encuentran en el segundo frame. Para ello se selecciona el `mainFrame` y en el `mainFrame` se selecciona el `rightFrame`.\n\nAdemás, se desea buscar todos los resultados que tengan la palabra \"Municipalidad\" en su texto. Para esto se busca y selecciona el cuadro donde se escribe y se coloca el texto.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwebElems <- remDr$findElements(\"name\",\"mainFrame\")\nremDr$switchToFrame(webElems[[1]])\nwebElems2 <- remDr$findElements(\"name\",\"rightFrame\")\nremDr$switchToFrame(webElems2[[1]])\n\n# Se busca el identificador para la descripción de procedimiento\n\nDescProc <- remDr$findElement(\"name\", \"cartelNm\") \n\nDescProc$sendKeysToElement(list(\"Municipalidad\")) # Se escribe lo que interesa\n```\n:::\n\n\nSi se desea cambiar la fecha de búsqueda es posible realizarlo de la siguiente manera. Específicamente, se cambia la fecha de rangos de publicación, mientras que la fecha máxima usualmente corresponde al día en que se consulte.\n\n## Llenado de formularios\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Cambiar fecha\n\ndd <- \"01\" # Día\nmm <- \"01\" # Mes\naa <- \"2010\" # Año\n\nstrdate <- paste0(dd,mm,aa)\n\n# Se encuentra el cuadro de fecha con el xpath\n\nfecha <- remDr$findElement(\"xpath\", '//*[@id=\"regDtFrom\"]')\n\n# Se clickea la fecha\nfecha$clickElement() \n\n# Se borra la fecha que está puesta por default\nfecha$clearElement() \n\n# Se escribe lo que interesa\nfecha$sendKeysToElement(list(strdate)) \n```\n:::\n\n\nEnseguida, se busca la opción de \"Estado del Concurso\" mediante su `xpath`, el cual se obtiene desde el navegador. Se selecciona la opción \"Todos\"\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Estado del concurso\nremDr$findElement(\"xpath\",\n                  \"/html/body/div[1]/div/div[2]/form[1]/table/tbody/tr[12]/td/select/option[1]\")$clickElement()\n```\n:::\n\n\n## Obtención de información tabulada\n\nFinalmente, para realizar la búsqueda se realiza click al cuadro de `consultar` especificando mediante su `xpath`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Para consultar\n# Se hace una variable para con la consulta para facilitar el ejemplo\nConsultar <- remDr$findElement(\"xpath\", \"/html/body/div[1]/div/div[2]/p/span/a\") \n\n# Se hace click en consultar (por xpath)\nConsultar$clickElement() \n```\n:::\n\n\nAl realizar la búsqueda se aprecia que los contenidos se encuentran en una tabla y además existe una cantidad de páginas con más tablas. Si se desea obtener todo el contenido de todas las páginas entonces el objetivo es la obtención de todas las tablas por cada páginas.\n\nSin embargo para comprender como funciona la obtención de información, se puede realizar por pasos. Para obtener la primera tabla se puede realizar lo siguiente:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_html(remDr$getPageSource()[[1]]) %>% \n  html_nodes(xpath = \"/html/body/div[1]/div/div[2]/table[2]\") %>% \n  html_table(trim = T)\n```\n:::\n\n\nY al ejecutar el código se obtiene un resultado similar al siguiente:\n\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped\" style=\"width: auto !important; \">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Número.de.procedimiento.Nombre.de.la.institución </th>\n   <th style=\"text-align:left;\"> Descripción.del.procedimiento </th>\n   <th style=\"text-align:left;\"> Fecha.hora.depublicación </th>\n   <th style=\"text-align:left;\"> Fecha.hora.deapertura </th>\n   <th style=\"text-align:left;\"> Estado.del.concurso </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> 2022CD-000040-0004300001MUNICIPALIDAD DE CORREDORES </td>\n   <td style=\"text-align:left;\"> [CD] CONTRATACIÓN DE REPUESTOS Y SERVICIOS DE MANTENIMIENTO PARA VEHÍCULO SM-4770 DE LA MUNICIPALIDAD DE CORREDORES Encargado de publicación, gestión de objeciones y apertura: REYMOND GONZALEZ ZUÑIGA </td>\n   <td style=\"text-align:left;\"> 22/12/2022 10:13 </td>\n   <td style=\"text-align:left;\"> 23/12/2022 12:01 </td>\n   <td style=\"text-align:left;\"> En recepción de ofertas </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 2022CD-000242-0002200001MUNICIPALIDAD DE MORA </td>\n   <td style=\"text-align:left;\"> [CD] COMPRA DE CALZADO PARA LOS CUERPOS POLICIALES DE LA MUNICIPALIDAD DE MORA Encargado de publicación, gestión de objeciones y apertura : GEREMMY DE LOS ANGELES CHAVES MARIN </td>\n   <td style=\"text-align:left;\"> 21/12/2022 10:51 </td>\n   <td style=\"text-align:left;\"> 23/12/2022 14:00 </td>\n   <td style=\"text-align:left;\"> En recepción de ofertas </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 2022LD-000003-0003100001Municipalidad de Puntarenas </td>\n   <td style=\"text-align:left;\"> [LD] CONTRATACIÓN DE SERVICIOS PROFESIONALES PARA LA ELABORACION DE LOS MANUALES DE PROCEDIMIENTOS FINANCIERO CONTABLES DE LA MUNICIPALIDAD DE PUNTARENAS Encargado de publicación, gestión de objeciones y apertura : LUIS EDWARD ROJAS BARRANTES </td>\n   <td style=\"text-align:left;\"> 21/12/2022 09:33 </td>\n   <td style=\"text-align:left;\"> 23/12/2022 15:00 </td>\n   <td style=\"text-align:left;\"> En recepción de ofertas </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 2022CD-000204-0002300005Municipalidad de Sarapiquí </td>\n   <td style=\"text-align:left;\"> [CD] CONTRATACIÓN DE SERVICIOS AUXILIARES PARA DEPARTAMENTO DE BIENES INMUEBLES DE LA MUNICIPALIDAD DE SARAPIQUI Encargado de publicación, gestión de objeciones y apertura : ELVIN HERNANDEZ LORIA </td>\n   <td style=\"text-align:left;\"> 20/12/2022 17:45 </td>\n   <td style=\"text-align:left;\"> 22/12/2022 12:00 </td>\n   <td style=\"text-align:left;\"> En apertura </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> 2022CD-000203-0002300005Municipalidad de Sarapiquí </td>\n   <td style=\"text-align:left;\"> [CD] Solicitud de contratación de servicios auxiliares para el departamento de plataforma de servicios de la Municipalidad de Sarapiquí. Encargado de publicación, gestión de objeciones y apertura : ADILIA SANCHEZ MONTOYA </td>\n   <td style=\"text-align:left;\"> 20/12/2022 16:01 </td>\n   <td style=\"text-align:left;\"> 22/12/2022 12:00 </td>\n   <td style=\"text-align:left;\"> En apertura </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n::: callout-note\nÚnicamente se colocan 5 elementos para facilitar la visibilidad. El código podría devolver más o menos concursos según los parámetros de búsqueda o la misma existencia de concursos.\n:::\n\n## Capturas de pantalla\n\nDicha tabla correspondería al contenido de tabla actual de la página web de SICOP. De igual forma puede realizarse un \"screenshot\" el contenido actual de la página de la siguiente manera:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Si usas esta opción, la pestaña se maximiza y el screnshot abarcará más área\n# remDr$maxWindowSize() \n\nremDr$screenshot(file = \"output/ss/SICOP_Municipalidad.png\")\n```\n:::\n\n\nEl screenshot se vería de la siguiente forma:\n\n![](output/ss/SICOP_Municipalidad.png)\n\n# Obtención de datos detallados\n\nSegún la tarea que se realice, puede que interese la obtención de más detalles en la misma página web. En la página de SICOP, al dar click en alguno de las descripciones de procedimientos es posible obtener información más detallada de cada concurso. Mediante el lenguaje R y RSelenium es posible; para esto hay que obtener el xpath de la descripción que se desea clickear.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Se busca el xpath y se clickea\nremDr$findElement(\"xpath\", \n                  \"/html/body/div[1]/div/div[2]/table[2]/tbody/tr[2]/td[2]/a[1]\"\n                  )$clickElement()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhtml <- read_html(remDr$getPageSource()[[1]])\n\n\nread_html(remDr$getPageSource()[[1]]) %>% \n  html_nodes(xpath = \"/html/body/div/div/div[2]/table[3]\") %>% \n  html_table(trim = T)\n```\n:::\n\n\nEntonces, un método más adecuado sería la obtención de los nombres de columna y los contenidos de columna por separado. Esto es posible dado que cada nombre de columna posee un contenido de celda (es decir, no hay más de uno o de otro). Para esto se obtiene el `xpath` de la tabla de interés (ya que hay varias en la página web), se extrae el código fuente, se extraen los nombres de celda, los contenidos de celda y se asigna un identificador de columna para facilitar el pivot de la tabla.\n\nAl pasar la tabla a formato largo, se asignan los nombres de columna que fueron obtenidos\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhtml <- read_html(remDr$getPageSource()[[1]]) %>% \n  html_nodes(xpath = \"/html/body/div/div/div[2]/table[3]\")\n\nnomb.column <- html %>% \n  html_nodes(\"th.epcthl\") %>%\n  html_text() %>% \n  str_trim(side = \"both\") %>%\n  str_squish() %>% \n  make.names()\n\ncontenido <- html %>% \n  html_nodes(\"td.eptdl\") %>% \n  html_text() %>% \n  str_trim(side = \"both\") %>% \n  str_squish() \n```\n:::\n\n\n::: column-margin\n`tp.epcthl` es el nodo de los nombres de columna de la tabla.\n\n`td.eptdl` es el nodo del contenido de la tabla\n\nSe utiliza `str_trim(side = \"both\")` para limpiar los espacios en blanco al final y al inicio del contenido.\n\nSe utiliza `str_squish()` para limpiar espacios en blanco adentro del string\n:::\n\nPara regresar a la página donde se encuentra el resto de concursos únicamente se debe especificar lo siguiente:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nremDr$goBack()\n```\n:::\n\n\nYa obtenidos los nombres de columna y contenidos se procede a dar estructura a la tabla. Se puede realizar de la siguiente manera:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Se realiza un dataframe en blanco con número de columnas igual\n# al largo del \"nomb.column\" que será los nombres de columna\ndf0 <- data.frame(matrix(ncol = length(nomb.column))) \n\n\n# Se asigna la fila con el contenido\ndf0[nrow(df0),] <- contenido\n\n# Se asignan nombres de columna\ncolnames(df0) <- nomb.column \n```\n:::\n\n\nEl resultado de la tabla obtenida debería ser similar a la siguiente (para facilitar la visualización únicamente se muestran 3 elementos de la tabla):\n\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped\" style=\"width: auto !important; \">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Nombre.de.la.institución </th>\n   <th style=\"text-align:left;\"> Descripción.del.procedimiento </th>\n   <th style=\"text-align:left;\"> Clasificación.del.objeto </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;font-weight: bold;border-right:1px solid;\"> MUNICIPALIDAD DE CORREDORES </td>\n   <td style=\"text-align:left;width: 30em; \"> CONTRATACIÓN DE REPUESTOS Y SERVICIOS DE MANTENIMIENTO PARA VEHÍCULO SM-4770 DE LA MUNICIPALIDAD DE CORREDORES </td>\n   <td style=\"text-align:left;\"> BIENES/SERVICIOS </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nLo que se realizó fue el webscrape de los elementos de la siguiente \"tabla\":\n\n![](images/image-1589146602.png)\n\n## Utilización de loops para obtener grandes volúmenes de información\n\nAl tener la estructura básica para obtener la información de una página web, es posible aplicar la misma fórmula para obtener grandes cantidades de información de la misma página web. Para esto es posible utilizar el loop `for`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ejemplo de utilización de un loop \"for\"\n\nfor (x in 1:10) { # Se brinda una secuencia la cual será seguida por la variable\n  print(x) # Se indica que devuelva el valor de la variable\n  # Al finalizar devolverá el siguiente valor que corresponde a la variable del loop\n}\n```\n:::\n\n\nEn el caso estudiado si se obtiene una secuencia que implique toda la información que se desea obtener, es posible aplicar dicho loop para obtener la misma. Para esto es necesario analizar un poco la estructura de la página.\n\nSe puede realizar de diferentes formas pero en este caso se buscará el patrón para cada nodo donde se clickea para obtener información específica del concurso. Al analizar la secuencia de concursos se aprecia lo siguiente:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# xpath para el primer concurso de la página\n\"/html/body/div[1]/div/div[2]/table[2]/tbody/tr[2]/td[2]/a[1]\"\n\n# xpath para el último concurso de la página\n\"/html/body/div[1]/div/div[2]/table[2]/tbody/tr[11]/td[2]/a[1]\"\n```\n:::\n\n\nEl `tr[x]` aumenta en número según el concurso que corresponda. Asumiendo una página llena de concursos, tendríamos 10 concursos por página. No obstante si se desean obtener todos los concursos de todas las páginas, llegará el momento en que una de estas páginas no tendrá 10 concursos en la página; para evitar problemas con esto es posible buscar una condición que indique el número de concursos que hay por página.\n\nUn método para obtener la cantidad de concursos sería obtener la tabla de concursos y saber cuantos elementos hay en la misma. Para evitar el cambio entre frames, es posible utilizar el link directo al frame donde se encontrarían las tablas (este es un frame dentro del `mainFrame`). Este link puede obtenerse mediante el método utilizado en la explicación del cambio entre frames.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nremDr$switchToFrame(NA) # Si hay un frame enfocado, se quita el focus.\n\n# Se cambia al mainFrame\nremDr$switchToFrame(webElems[[1]]) # Se cambia al mainFrame\n\n# Se busca el identificador de los frames\nwebElems <- remDr$findElements(\"tag name\",\"frame\")\n\n# Se aprecian los enlaces de frames existentes, interesa el frame \"moduloOferta\"\n# Así que se guarda su valor en un string\nsapply(webElems, function(x){x$getElementAttribute(\"src\")})\n\nlink_tabla <- as.character(sapply(webElems, function(x){x$getElementAttribute(\"src\")})[2])\n```\n:::\n\n\nObtenido el frame mencionado, ya no es necesario cambiar constantemente entre frames y con esto es posible ahorrar el espacio del código que pudo ser usado para ello. Ahora es posible realizar la misma búsqueda como la realizada en la primera sección.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Se realiza lo mismo que se realizó al inicio\n# Pero en este caso no es necesario cambiar entre frames\n\nremDr$switchToFrame(NA) # Si hay un frame enfocado, se quita el focus.\n\n# Página de SICOP para buscar concursos\n\nremDr$navigate('https://www.sicop.go.cr/moduloOferta/search/EP_SEJ_COQ600.jsp')\n\n# Se busca el identificador para la descripción de procedimiento\n\nDescProc <- remDr$findElement(\"name\", \"cartelNm\") \n\nDescProc$sendKeysToElement(list(\"Municipalidad\"))\n\n# Cambiar fecha\n\ndd <- \"01\" # Día\nmm <- \"01\" # Mes\naa <- \"2010\" # Año\n\nstrdate <- paste0(dd,mm,aa)\n\n# Se encuentra el cuadro de fecha con el xpath\nfecha <- remDr$findElement(\"xpath\", '//*[@id=\"regDtFrom\"]')\n\nfecha$clickElement()\nfecha$clearElement()\nfecha$sendKeysToElement(list(strdate))\n\nremDr$findElement(\"xpath\",\"/html/body/div[1]/div/div[2]/form[1]/table/tbody/tr[12]/td/select/option[1]\")$clickElement()\n\n# Para consultar\n# Se hace una variable para con la consulta para facilitar el ejemplo\nConsultar <- remDr$findElement(\"xpath\", \"/html/body/div[1]/div/div[2]/p/span/a\") \nConsultar$clickElement() \n```\n:::\n\n\nPara obtener el número de concursos para cada página es posible realizar lo siguiente:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# se extrae numero de paginas\nnum_pag <- read_html(remDr$getPageSource()[[1]]) %>%\n  # Se especifica lo que contiene el número de páginas\n  html_nodes(\"li a\") %>% \n  html_text() \n\n# Se remueven los elementos en blanco\nnum_pag <- num_pag[num_pag != \"\"]\n```\n:::\n\n\nLuego se plantea el loop para obtener todas las tablas por cada página del set de páginas (de la página 1 a la página 10 únicamente).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(\"df0\",\"df1\",\"i\",\"df2\")\n\n# Inicio del loop\n\nfor (i in num_pag) {\n\n# Si existe el df \"df0\" no se hace nada (se enseña un mensaje)\n# Si no existe se crea un df en blanco con x cantidad de columnas\n  \nifelse(exists(\"df0\"),paste0(\"Procesando página \",i,\"...\"),\n       assign(\"df0\",data.frame(matrix(ncol = length(1:5),nrow = 0))))\n  \n  # Se lee el código fuente, se busca el nodo con xpath, se extrae la tabla\n  # Y se pasa a un objeto data frame\n  \n  df1 <- read_html(remDr$getPageSource()[[1]]) %>% \n    html_nodes(xpath = \"/html/body/div[1]/div/div[2]/table[2]\") %>%\n    html_table() %>%\n    as.data.frame()\n\n  # Se asignan nombres de columna del df1 al df0\n  colnames(df0) <- colnames(df1)\n\n  # Se combina el df en blanco y el df con datos\n  df0 <- rbind(df0,df1) #\n\n  # Se crea una nueva variable dado que el número de página no corresponde al número\n  # para pasar de página según el xpath\n  jj <- as.numeric(i)-1\n\n  # Si el número de página es mayor a 2, entonces antes de pasar de página se volverá a\n  # la página 1 antes de ir a la siguiente página (esto dado que el xpath cambia\n  # según la página en que se encuentre)\n  if (i > 2) {\n    remDr$goBack # Ir hacia la página anterior\n    remDr$findElement(\"xpath\", # Ir a la siguiente página\n                      paste0('//*[@id=\"paging\"]/ul/li/a[',jj,']'))$clickElement() \n  } else{\n    remDr$findElement(\"xpath\", # Ir a la siguiente página\n                      paste0('//*[@id=\"paging\"]/ul/li/a[',jj,']'))$clickElement()\n  }\n  \n}\n```\n:::\n\n\nDespués de llegar al final del número de páginas que fueron obtenidas y almacenadas en la variable \"num_pag\", es posible seguir con el siguiente set de páginas. Para esto es posible indicar que cuanto se termine el loop de un set de páginas, se pase al siguiente set de páginas y se obtenga nuevamente el número de páginas para el nuevo set. Al revisar los `xpath` para pasar al siguiente set de páginas se obtiene lo siguiente:\\\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# xpath para pasar al segundo set de páginas\n'//*[@id=\"paging\"]/ul/li/a[10]' \n\n# xpath para pasar el resto de set de páginas\n'//*[@id=\"paging\"]/ul/li/a[12]' \n```\n:::\n\n\nExiste diferencia entre el `xpath` para pasar al segundo set de páginas y el que permite pasar el resto de set de páginas. Alternativamente, para evitar el uso de código adicional puede utilizarse un identificador de nombre en lugar de un `xpath`. El identificador de nombre para pasar de set de páginas en este caso es \"page02\" (se obtiene \"inspeccionando\" en el navegador). Entonces, pasar pasar cualquier set de páginas es posible realizar lo siguiente:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Click siguiente set de paginas\n\nremDr$findElement(\"class name\", \"page02\")$clickElement() \n```\n:::\n\n\nAdemás de pasar de páginas, para realizar el loop es necesario cuando debe detenerse el mismo. Para esto es posible determinar la cantidad de set de páginas de antemano. Entonces es posible obtener el `xpath` que indica la cantidad máxima de páginas de los concursos. A no ser que exista un cambio mientras se obtiene la información, no sería necesario que este paso se encuentre adentro del loop.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# se extrae numero de paginas\n\ntot_pags <- read_html(remDr$getPageSource()[[1]]) %>% \n  # Se especifica lo que contiene el número de páginas\n  html_nodes(xpath = '//*[@id=\"total\"]/span[3]') %>% \n  html_text() %>% \n  # Se pasa a numérico\n  as.numeric()\n\ntot_pags\n```\n:::\n\n\nAhora se crea una variable que cambiará según la cantidad total de páginas. Esta ayudará a determinar cuando se detendrá el loop. Se divide entre 10 el número total de páginas y se divide hacia abajo el resultado; esto hará que al llegar a la última página, termine el loop\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Se coloca nuevamente la asignación de esta variable para facilitar la comprensión de\n# donde proviene el \"set_pags\"\n\nset_pags <- ceiling(tot_pags/10) # Floor para redondear hacia arriba\nset_pags                         # Se visualiza el resultado\n```\n:::\n\n\nEntonces, ya se posee suficiente código para ensamblar el loop, excepto que se realizará el mismo obteniendo mayores detalles de cada concurso (lo cual se realizó anteriormente). El fin es la obtención de los detalles de cada concurso pero a lo largo de todas las páginas y sets de páginas existentes para el momento de ejecución del código. Para ello existiría una jerarquía de loops, de mayor a menos: una que itere sobre los sets de páginas, otra que itere sobre los números de página de los sets de páginas y otra que itere sobre cada elemento de tabla de la página.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Se coloca el xpath en dos variables para que al concatenarlas\n# sea posible colocar en medio la variable de iteración\n\nxp1 <- \"/html/body/div[1]/div/div[2]/table[2]/tbody/tr[\"\nxp2 <- \"]/td[2]/a[1]\"\n```\n:::\n\n\nEntonces se procede a plantear el loop:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Loop para los sets de páginas\n\nfor (i in 1:set_pags) { \n  num_pag <- read_html(remDr$getPageSource()[[1]]) %>%\n    html_nodes(\"li a\") %>% \n    html_text()\n  num_pag <- num_pag[num_pag != \"\"]\n  num_pag <- length(num_pag)+1\n\n  # Loop para las páginas de un set\n\n  for (ii in 1:(max(num_pag))) { \n  \n    # Si el número de iteración es mayor a 1 entonces\n    # se pasará la página\n  \n    if (ii > 1){\n      remDr$findElement(\"xpath\",\n      paste0('//*[@id=\"paging\"]/ul/li/a[',ij,']'))$clickElement()\n    }\n  \n    # Se determina el número de concursos que tiene la tabla\n    # para la determinada página\n  \n    nrow_tab <- read_html(remDr$getPageSource()[[1]]) %>% \n      html_nodes(xpath = \"/html/body/div[1]/div/div[2]/table[2]\") %>%\n      html_table() %>%\n      as.data.frame() %>% \n      nrow() \n  \n    # Loop para los rows\n  \n    for (j in 1:nrow_tab) { \n      print(paste0(\"Scrapeando contenido del concurso \",j))\n      jj <- as.numeric(j) + 1\n      \n      # Se clickea en el elemento j de la tabla\n      \n      remDr$findElement(\"xpath\", paste0(xp1,jj,xp2))$clickElement()\n      \n      # Se obtiene el código y se guarda en una variable\n      \n      html <- read_html(remDr$getPageSource()[[1]]) %>% \n        html_nodes(xpath = \"/html/body/div/div/div[2]/table[3]\")\n      \n      # Se obtienen los nombres de columna\n      \n      nomb.column <- html %>%\n        html_nodes(\"th.epcthl\") %>%\n        html_text() %>% \n        str_trim(side = \"both\") %>%\n        str_squish() %>% \n        make.names()\n       \n      # Se obtiene el contenido\n        \n      contenido <- html %>% \n        html_nodes(\"td.eptdl\") %>%\n        html_text() %>% \n        str_trim(side = \"both\") %>% \n        str_squish()\n      \n      # Se realiza un df en blanco del largo de nomb.column\n      \n      assign(\"df0\",data.frame(matrix(ncol = length(nomb.column))))\n      \n      # Se asignan los nombres de columna\n      # Se asigna el contenido al df\n\n      colnames(df0) <- nomb.column\n      df0[nrow(df0),] <- contenido\n\n      # Si existe \"df_concursos\" se le agrega df0\n      # si no existe, df0 será df_concursos\n      \n      ifelse(exists(\"df_concursos\"),\n             assign(\"df_concursos\",bind_rows(df0, df_concursos)),\n             assign(\"df_concursos\", df0))\n      \n      # Se remueven las variables innecesarias\n      \n      rm(df0,nomb.column,contenido,html)\n      \n      # Se vuelve a la página anterior\n      \n      remDr$goBack()\n    }\n  \n    # Si el set de páginas es mayor a 1 el numero para hacer click en xpath\n    # cambia y aumenta de 1 (en el primer set es 1 para la pagina 2) a 3 y\n    # por esta razón después de que el set de páginas es mayor a 1, se suma 2\n\n    if (i > 1) { \n      ij <- ii+2\n      } else{\n      ij <- ii\n      }\n  }\n\n# Si i (set de páginas) es igual a \"set_pags\" entonces\n# el webscrape terminó. De lo contrario dará click\n# en el siguiente set de páginas\n\nif (i == set_pags) {\n  print(\"Webscrape terminado\")\n  } else{\n\n    # Para pasar el set de    \n    remDr$findElement(\"class name\", \"page02\")$clickElement() \n  }\n}\n```\n:::\n\n\nEl resultado es un data frame con los detalles de los concursos publicados en SICOP que están relacionados con la palabra \"Municipalidad\" y que aun se encuentran o no en recepción de ofertas. La tabla debería lucir similar a la siguiente (solo se muestran algunos resultados para facilitar la visualización):\n\n\n::: {.cell}\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped\" style=\"width: auto !important; \">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Funcionarios.relacionados </th>\n   <th style=\"text-align:left;\"> Estado.del.concurso </th>\n   <th style=\"text-align:left;\"> Fecha.hora.de.publicación </th>\n   <th style=\"text-align:left;\"> Cartel </th>\n   <th style=\"text-align:left;\"> Número.de.procedimiento </th>\n   <th style=\"text-align:left;\"> Número.de.SICOP </th>\n   <th style=\"text-align:left;\"> Nombre.de.la.institución </th>\n   <th style=\"text-align:left;\"> Concurso.confidencial </th>\n   <th style=\"text-align:left;\"> Encargado.de.publicación..gestión.de.objeciones.y.apertura </th>\n   <th style=\"text-align:left;\"> Elaborador </th>\n   <th style=\"text-align:left;\"> Encargado.de.solicitar.estudio.de.ofertas.recomendación.del.acto.final </th>\n   <th style=\"text-align:left;\"> Registro.del.pliego.de.condiciones </th>\n   <th style=\"text-align:left;\"> Versiones.del.cartel </th>\n   <th style=\"text-align:left;\"> Versión.en.consulta </th>\n   <th style=\"text-align:left;\"> Descripción.del.procedimiento </th>\n   <th style=\"text-align:left;\"> Clasificación.del.objeto </th>\n   <th style=\"text-align:left;\"> Tipo.de.procedimiento </th>\n   <th style=\"text-align:left;\"> Tipo.de.modalidad </th>\n   <th style=\"text-align:left;\"> Tipo.de.recepción.de.ofertas </th>\n   <th style=\"text-align:left;\"> Lugar.de.apertura </th>\n   <th style=\"text-align:left;\"> Inicio.de.recepción.de.ofertas </th>\n   <th style=\"text-align:left;\"> Cierre.de.recepción.de.ofertas </th>\n   <th style=\"text-align:left;\"> Fecha.hora.de.apertura.de.ofertas </th>\n   <th style=\"text-align:left;\"> Plazo.del.acto.final </th>\n   <th style=\"text-align:left;\"> Presupuesto.total.estimado </th>\n   <th style=\"text-align:left;\"> Presupuesto.total.estimado.USD..Opcional. </th>\n   <th style=\"text-align:left;\"> Fundamento.jurídico </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> Funcionarios relacionados con el concurso </td>\n   <td style=\"text-align:left;\"> En evaluación </td>\n   <td style=\"text-align:left;\"> 02/05/2022 15:25 </td>\n   <td style=\"text-align:left;\"> Real </td>\n   <td style=\"text-align:left;\"> 2022LN-000001-0021700001 </td>\n   <td style=\"text-align:left;\"> - </td>\n   <td style=\"text-align:left;\"> Municipalidad de Heredia </td>\n   <td style=\"text-align:left;\"> No </td>\n   <td style=\"text-align:left;\"> Enio Vargas Arrieta </td>\n   <td style=\"text-align:left;\"> Enio Vargas Arrieta </td>\n   <td style=\"text-align:left;\"> Enio Vargas Arrieta </td>\n   <td style=\"text-align:left;\"> Modificar </td>\n   <td style=\"text-align:left;\"> 20220402880-01 20220402880-02 20220402880-03 20220402880-04 20220402880-05 20220402880-06 20220402880-07 </td>\n   <td style=\"text-align:left;\"> 20220402880-00 </td>\n   <td style=\"text-align:left;\"> CONTRATACION PARA SUMINISTRO MEZCLA ASFALTICA EN CARPETAS Y OTROS EN CUMPLIMIENTO POR DEMANDA PARA LA MUNICIPALIDAD DE HEREDIA </td>\n   <td style=\"text-align:left;\"> BIENES </td>\n   <td style=\"text-align:left;\"> LICITACIÓN PÚBLICA NACIONAL </td>\n   <td style=\"text-align:left;\"> Según demanda </td>\n   <td style=\"text-align:left;\"> En línea </td>\n   <td style=\"text-align:left;\"> https://www.sicop.go.cr </td>\n   <td style=\"text-align:left;\"> 04/08/2022 07:00 </td>\n   <td style=\"text-align:left;\"> 08/08/2022 10:00 </td>\n   <td style=\"text-align:left;\"> 08/08/2022 10:00 </td>\n   <td style=\"text-align:left;\"> 60 Días hábiles </td>\n   <td style=\"text-align:left;\"> 283.767,29 [CRC] </td>\n   <td style=\"text-align:left;\">  </td>\n   <td style=\"text-align:left;\"> NA </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Funcionarios relacionados con el concurso </td>\n   <td style=\"text-align:left;\"> Adjudicación en firme </td>\n   <td style=\"text-align:left;\"> 07/06/2022 14:53 </td>\n   <td style=\"text-align:left;\"> Real </td>\n   <td style=\"text-align:left;\"> 2022LA-000001-0003100001 </td>\n   <td style=\"text-align:left;\"> - </td>\n   <td style=\"text-align:left;\"> Municipalidad de Puntarenas </td>\n   <td style=\"text-align:left;\"> No </td>\n   <td style=\"text-align:left;\"> LUIS EDWARD ROJAS BARRANTES </td>\n   <td style=\"text-align:left;\"> LUIS EDWARD ROJAS BARRANTES </td>\n   <td style=\"text-align:left;\"> LUIS EDWARD ROJAS BARRANTES </td>\n   <td style=\"text-align:left;\"> Modificar </td>\n   <td style=\"text-align:left;\"> 20220600067-01 20220600067-02 20220600067-03 20220600067-04 20220600067-05 </td>\n   <td style=\"text-align:left;\"> 20220600067-00 </td>\n   <td style=\"text-align:left;\"> ADQUISICION DE UNIFORMES PARA LOS FUNCIONARIOS DE LA MUNICIPALIDAD DE PUNTARENAS, BAJO LA MODALIDAD DE ENTREGA SEGÚN DEMANDA POR UN PERIODO DE CUATRO AÑOS. </td>\n   <td style=\"text-align:left;\"> BIENES </td>\n   <td style=\"text-align:left;\"> LICITACIÓN ABREVIADA </td>\n   <td style=\"text-align:left;\"> Según demanda </td>\n   <td style=\"text-align:left;\"> En línea </td>\n   <td style=\"text-align:left;\"> https://www.sicop.go.cr </td>\n   <td style=\"text-align:left;\"> 07/06/2022 15:00 </td>\n   <td style=\"text-align:left;\"> 31/08/2022 15:00 </td>\n   <td style=\"text-align:left;\"> 31/08/2022 15:00 </td>\n   <td style=\"text-align:left;\"> 20 Días hábiles </td>\n   <td style=\"text-align:left;\"> 17.746.000 [CRC] </td>\n   <td style=\"text-align:left;\">  </td>\n   <td style=\"text-align:left;\"> NA </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Funcionarios relacionados con el concurso </td>\n   <td style=\"text-align:left;\"> Contrato </td>\n   <td style=\"text-align:left;\"> 06/07/2022 09:12 </td>\n   <td style=\"text-align:left;\"> Real </td>\n   <td style=\"text-align:left;\"> 2022LA-000001-0021300211 </td>\n   <td style=\"text-align:left;\"> - </td>\n   <td style=\"text-align:left;\"> Municipalidad de Zarcero </td>\n   <td style=\"text-align:left;\"> No </td>\n   <td style=\"text-align:left;\"> MARIA VANESSA SALAZAR HUERTAS </td>\n   <td style=\"text-align:left;\"> MARIA VANESSA SALAZAR HUERTAS </td>\n   <td style=\"text-align:left;\"> MARIA VANESSA SALAZAR HUERTAS </td>\n   <td style=\"text-align:left;\"> Modificar </td>\n   <td style=\"text-align:left;\"> 20220700524-01 20220700524-02 </td>\n   <td style=\"text-align:left;\"> 20220700524-00 </td>\n   <td style=\"text-align:left;\"> Adquisición de servicio para elaboración Plan conservación, desarrollo y seguridad vial Red vial (Plan Quinquenal), Municipalidad de Zarcero </td>\n   <td style=\"text-align:left;\"> SERVICIOS </td>\n   <td style=\"text-align:left;\"> LICITACIÓN ABREVIADA </td>\n   <td style=\"text-align:left;\"> Servicios </td>\n   <td style=\"text-align:left;\"> En línea </td>\n   <td style=\"text-align:left;\"> https://www.sicop.go.cr </td>\n   <td style=\"text-align:left;\"> 07/07/2022 08:00 </td>\n   <td style=\"text-align:left;\"> 03/08/2022 08:45 </td>\n   <td style=\"text-align:left;\"> 03/08/2022 09:00 </td>\n   <td style=\"text-align:left;\"> 24 Días hábiles </td>\n   <td style=\"text-align:left;\"> 24.000.000 [CRC] </td>\n   <td style=\"text-align:left;\">  </td>\n   <td style=\"text-align:left;\"> NA </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../site_libs/kePrint-0.0.1/kePrint.js\"></script>\r\n<link href=\"../../site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}