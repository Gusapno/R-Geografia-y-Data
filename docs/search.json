[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R, Geografía y Data",
    "section": "",
    "text": "Webscraping básico con RSelenium\n\n\n\n\n\n\n\nWebscraping\n\n\nRSelenium\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nDec 23, 2022\n\n\nGabriel Ramírez\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/SICOP/index.html",
    "href": "posts/SICOP/index.html",
    "title": "Webscraping básico con RSelenium",
    "section": "",
    "text": "En este proyecto se obtienen datos del Sistema Integrado de Compras Públicas (SICOP) por municipalidad. El fin es realizar un análisis descriptivo y espacializar los datos por municipalidad o institución (cantón o localización de municipalidad).\nEste sistema se autodenomina como una novedosa herramienta para la realización de negocios vía web. De forma más específica, permite a las proveedurías del Estado realizar compra y venta de servicios y productos de forma electrónica.\nEste modelo de compras se realizó tras un análisis de prácticas efectuadas por países como Chile, Panamá, México, Brasil y Corea. Dicho estudio finalizó con la adopción del modelo de Corea del Sur, por ser lider mundial en esta temática (compras electrónicas); mediante su sistema de gestión denominado Korea On Line e-Procurement System (Koneps), definido como el ‘marketplace’ más grande del mundo. Este modelo, mencionan en información de SICOP (SICOP, 2015)."
  },
  {
    "objectID": "posts/SICOP/index.html#carga-de-librerías-y-directorio-de-trabajo",
    "href": "posts/SICOP/index.html#carga-de-librerías-y-directorio-de-trabajo",
    "title": "Webscraping básico con RSelenium",
    "section": "2.1 Carga de librerías y directorio de trabajo",
    "text": "2.1 Carga de librerías y directorio de trabajo\nEl directorio de trabajo depende de donde se encuentre el archivo de trabajo.\n\nsetwd(\"~/GitHub/R-Geografia-y-Data/posts/SICOP/\") # Directorio de trabajo\n\n# Paquetes a utilizar\n\nlibrary(RSelenium)\nlibrary(tidyverse)\nlibrary(rvest)\nlibrary(xml2)\nlibrary(stringi)\nlibrary(seleniumPipes)\nlibrary(XML)\nlibrary(knitr)\nlibrary(kableExtra)"
  },
  {
    "objectID": "posts/SICOP/index.html#inicio-del-server-de-selenium-y-el-navegador",
    "href": "posts/SICOP/index.html#inicio-del-server-de-selenium-y-el-navegador",
    "title": "Webscraping básico con RSelenium",
    "section": "2.2 Inicio del server de selenium y el navegador",
    "text": "2.2 Inicio del server de selenium y el navegador\nEs posible elaborar un código para conocer cuales son las ofertas que se encuentran en etapa de recepción de ofertas en el SICOP. Dada la estructura de la página se utiliza la libreria RSelenium en lugar de rvest. Esto dado que se trata de un sitio web interactivo.\nSe puede iniciar con la creación de un servidor para navegar.\n\n# Este script permite obtener los concursos de \n# municipalidades que se encuentran en la etapa de recepción de ofertas\n\n# Empezar el servidor\nrs_driver_object <- rsDriver(browser = 'chrome', # Se utilizará Google Chrome\n                             chromever = '108.0.5359.71', # Versión de Chrome\n                             verbose = FALSE, # No incluir mensajes de estado\n                             port = free_port(), # Se utiliza un puerto libre\n                             check = TRUE) # Checar si hay nuevas versiones\n\nDespués de la creación del servidor, se puede crear un objeto cliente y se asigna a una variable. También se abre el navegador y la página web de SICOP.\n\n# crear un objeto cliente\nremDr <- rs_driver_object$client\n\n# Se navega a la página de interés\n\nremDr$navigate('https://www.sicop.go.cr/index.jsp') # \n\nAl estar en la página web interesa irse a la sección de la misma en donde se encuentra la información de los concursos actuales. La página web principal de SICOP se conforma por dos frames. El botón para ir a los concursos de encuentra en el primer frame, para poder clickearlo es necesario hacerle énfasis al primer frame.\n\n# Se busca el identificador de los frames\n\nwebElems <- remDr$findElements(\"tag name\",\"frame\")\n\n# Se aprecian los enlaces de frames existentes\n\nsapply(webElems, function(x){x$getElementAttribute(\"src\")})\n\nPodemos apreciar que existen dos frames, los cuales corresponden al “top frame” y al “middle frame”. Esto también puede analizarse desde el código fuente de la página web, lo cual es permitido por algunos navegadores\n\n\n\nParte del código fuente donde se aprecia la estructura de la página\n\n\nAl comprobar cual de los dos frames corresponde al frame donde se encuentra la opción para buscar los concursos, se selecciona el mismo (recordar que se guardaron los frames en la variable “webElems”, entonces nada más se selecciona el frame de arriba o “topFrame”)\nYa seleccionado el frame que nos interesa, es posible hacer click en sus elementos. En este caso se realiza click en la pestaña de concursos. Para ello se utiliza el “xpath” el cual se puede obtener con la opción de “inspeccionar elemento” que ofrecen algunos navegadores.\n\n# Se cambia al frame 1 (topFrame)\n\nremDr$switchToFrame(webElems[[1]])\n\n# Se busca el elemento de interés e inmediatamente se clickea el mismo\n\nremDr$findElement(\"xpath\", # Se especifica el método de búsqueda y se coloca el identificador\n                  \"/html/body/div[2]/div/div/div[4]/ul/li[2]/div[1]/a[3]\")$clickElement() # Se clickea\n\nAl estar en la página donde se colocan los parámetros de búsqueda, es posible continuar. No obstante, recordar que hicimos enfoque a un frame específico de la página. De acuerdo a la documentación únicamente debemos utilizar la misma función pero asignarle “NULL” en el argumento; a pesar de estar en la documentación dicho método no funciona y es necesario colocar “NA” en lugar de “NULL” para regresar al frame principal.\n\nremDr$switchToFrame(NA) #\n\n# Se busca el identificador de los frames\n\nwebElems <- remDr$findElements(\"tag name\",\"frame\")\n\n# Se aprecian los enlaces de frames existentes\n\nsapply(webElems, function(x){x$getElementAttribute(\"src\")})\n\nApreciamos nuevamente que existen dos frames, pero al analizar la estructura de la página, vemos que el frame con los parámetros para buscar se encuentran en el segundo frame. Para ello se selecciona el mainframe y en el mainframe se selecciona el rightframe.\nAdemás, se desea buscar todos los resultados que tengan “Municipalidad” en su texto. Para esto se busca y selecciona el cuadro donde se escribe y se coloca el texto.\n\nwebElems <- remDr$findElements(\"name\",\"mainFrame\")\nremDr$switchToFrame(webElems[[1]])\nwebElems2 <- remDr$findElements(\"name\",\"rightFrame\")\nremDr$switchToFrame(webElems2[[1]])\n\n# Se busca el identificador para la descripción de procedimiento\n\nDescProc <- remDr$findElement(\"name\", \"cartelNm\") \n\nDescProc$sendKeysToElement(list(\"Municipalidad\")) # Se escribe lo que interesa\n\nSi se desea cambiar la fecha de búsqueda es posible realizarlo de la siguiente manera. Específicamente, se cambia la fecha de rangos de publicación, mientras que la fecha máxima usualmente corresponde al día en que se consulte."
  },
  {
    "objectID": "posts/SICOP/index.html#llenado-de-formularios",
    "href": "posts/SICOP/index.html#llenado-de-formularios",
    "title": "Webscraping básico con RSelenium",
    "section": "2.3 Llenado de formularios",
    "text": "2.3 Llenado de formularios\n\n# Cambiar fecha\n\ndd <- \"01\" # Día\nmm <- \"01\" # Mes\naa <- \"2010\" # Año\n\nstrdate <- paste0(dd,mm,aa) # deben ser de tipo string o si no se borran los ceros\n\n# Se encuentra el cuadro de fecha con el xpath\n\nfecha <- remDr$findElement(\"xpath\", '//*[@id=\"regDtFrom\"]')\n\nfecha$clickElement() # Se clickea la fecha\nfecha$clearElement() # Se borra la fecha que está puesta por default\nfecha$sendKeysToElement(list(strdate)) # Se escribe lo que interesa\n\nEnseguida, se busca la opción de “Estado del Concurso” mediante su xpath, el cual se obtiene desde el navegador. Se selecciona la opción “Todos”\n\nremDr$findElement(\"xpath\",\"/html/body/div[1]/div/div[2]/form[1]/table/tbody/tr[12]/td/select/option[1]\")$clickElement() # Estado del concurso"
  },
  {
    "objectID": "posts/SICOP/index.html#obtención-de-información-tabulada",
    "href": "posts/SICOP/index.html#obtención-de-información-tabulada",
    "title": "Webscraping básico con RSelenium",
    "section": "2.4 Obtención de información tabulada",
    "text": "2.4 Obtención de información tabulada\nFinalmente, para realizar la búsqueda se realiza click al cuadro de “consultar” especificando mediante su “xpath”\n\n# Para consultar\n# Se hace una variable para con la consulta para facilitar el ejemplo\nConsultar <- remDr$findElement(\"xpath\", \"/html/body/div[1]/div/div[2]/p/span/a\") \nConsultar$clickElement() # Se hace click en consultar (por xpath)\n\nAl realizar la búsqueda se aprecia que los contenidos se encuentran en una tabla y además existe una cantidad de páginas con más tablas. Si se desea obtener todo el contenido de todas las páginas entonces el objetivo es la obtención de todas las tablas por cada páginas.\nSin embargo para comprender como funciona la obtención de información, se puede realizar por pasos. Para obtener la primera tabla se puede realizar lo siguiente:\n\nread_html(remDr$getPageSource()[[1]]) %>% \n  html_nodes(xpath = \"/html/body/div[1]/div/div[2]/table[2]\") %>% \n  html_table(trim = T)\n\nY al ejecutar el código se obtiene un resultado similar al siguiente:\n\n\n\n\n \n  \n    Número.de.procedimiento.Nombre.de.la.institución \n    Descripción.del.procedimiento \n    Fecha.hora.depublicación \n    Fecha.hora.deapertura \n    Estado.del.concurso \n  \n \n\n  \n    2022CD-000040-0004300001MUNICIPALIDAD DE CORREDORES \n    [CD] CONTRATACIÓN DE REPUESTOS Y SERVICIOS DE MANTENIMIENTO PARA VEHÍCULO SM-4770 DE LA MUNICIPALIDAD DE CORREDORES Encargado de publicación, gestión de objeciones y apertura: REYMOND GONZALEZ ZUÑIGA \n    22/12/2022 10:13 \n    23/12/2022 12:01 \n    En recepción de ofertas \n  \n  \n    2022CD-000242-0002200001MUNICIPALIDAD DE MORA \n    [CD] COMPRA DE CALZADO PARA LOS CUERPOS POLICIALES DE LA MUNICIPALIDAD DE MORA Encargado de publicación, gestión de objeciones y apertura : GEREMMY DE LOS ANGELES CHAVES MARIN \n    21/12/2022 10:51 \n    23/12/2022 14:00 \n    En recepción de ofertas \n  \n  \n    2022LD-000003-0003100001Municipalidad de Puntarenas \n    [LD] CONTRATACIÓN DE SERVICIOS PROFESIONALES PARA LA ELABORACION DE LOS MANUALES DE PROCEDIMIENTOS FINANCIERO CONTABLES DE LA MUNICIPALIDAD DE PUNTARENAS Encargado de publicación, gestión de objeciones y apertura : LUIS EDWARD ROJAS BARRANTES \n    21/12/2022 09:33 \n    23/12/2022 15:00 \n    En recepción de ofertas \n  \n  \n    2022CD-000204-0002300005Municipalidad de Sarapiquí \n    [CD] CONTRATACIÓN DE SERVICIOS AUXILIARES PARA DEPARTAMENTO DE BIENES INMUEBLES DE LA MUNICIPALIDAD DE SARAPIQUI Encargado de publicación, gestión de objeciones y apertura : ELVIN HERNANDEZ LORIA \n    20/12/2022 17:45 \n    22/12/2022 12:00 \n    En apertura \n  \n  \n    2022CD-000203-0002300005Municipalidad de Sarapiquí \n    [CD] Solicitud de contratación de servicios auxiliares para el departamento de plataforma de servicios de la Municipalidad de Sarapiquí. Encargado de publicación, gestión de objeciones y apertura : ADILIA SANCHEZ MONTOYA \n    20/12/2022 16:01 \n    22/12/2022 12:00 \n    En apertura \n  \n  \n    2022CD-000453-0022030101Municipalidad de Cartago \n    [CD] 21653 - ADQUISICION DE SISTEMA PARA LA DETECCION Y RESPUESTA DE INCIDENTES EN LA SEGURIDAD DE LA INFORMACION (EDR), PARA LA MUNICIPALIDAD DE CARTAGO. Encargado de publicación, gestión de objeciones y apertura : Jose Enrique Núñez Rangel \n    15/12/2022 15:57 \n    20/12/2022 08:01 \n    Desierto/Infructuoso \n  \n  \n    2022CD-000450-0022030101Municipalidad de Cartago \n    [CD] 21680 - La Municipalidad de Cartago, requiere ampliar la capacidad de almacenamiento de las matrices flash adaptativas HPE Nimble Storage con el fin d Encargado de publicación, gestión de objeciones y apertura : Jose Enrique Núñez Rangel \n    15/12/2022 15:52 \n    20/12/2022 07:00 \n    En evaluación \n  \n  \n    2022CD-000087-0003000001Municipalidad del Cantón de Flores \n    [CD] Contratación de Servicios Profesionales en Auditoría Externa para Estados Financieros y Liquidación Presupuestaria de los años 2019 y 2020 de la Municipalidad de Flores Encargado de publicación, gestión de objeciones y apertura : Cynthia Alejandra Salas Chavarría \n    15/12/2022 14:57 \n    19/12/2022 14:00 \n    En evaluación \n  \n  \n    2022CD-000240-0002200001MUNICIPALIDAD DE MORA \n    [CD] COMPRA DE SUMINISTROS, EQUIPO Y OTROS INSUMOS PARA LA COMISION MUNICIPAL DE EMERGENCIAS DE LA MUNICIPALIDAD DE MORA Encargado de publicación, gestión de objeciones y apertura : CINTHIA DE LOS ANGELES ARAYA DELGADO \n    15/12/2022 14:35 \n    20/12/2022 11:00 \n    En apertura \n  \n  \n    2022CD-000448-0022030101Municipalidad de Cartago \n    [CD] 21983 - La Municipalidad de Cartago requiere Adquirir licencias adicionales ya que las existente ya resultan insuficientes debido al crecimiento insti Encargado de publicación, gestión de objeciones y apertura : JENNY PATRICIA ELIZONDO CAMACHO \n    15/12/2022 08:59 \n    20/12/2022 08:00 \n    En evaluación \n  \n\n\n\n\n\n\n\n\n\n\n\nNota\n\n\n\nUtilizar el botón ubicado al lado superior derecho de la tabla para apreciar el resto de contenido de la tabla"
  },
  {
    "objectID": "posts/SICOP/index.html#capturas-de-pantalla",
    "href": "posts/SICOP/index.html#capturas-de-pantalla",
    "title": "Webscraping básico con RSelenium",
    "section": "2.5 Capturas de pantalla",
    "text": "2.5 Capturas de pantalla\nDicha tabla correspondería al contenido de tabla actual de la página web de SICOP. De igual forma puede realizarse un “screenshot” el contenido actual de la página de la siguiente manera:\n\n# Si usas esta opción, la pestaña se maximiza y el screnshot abarcará más área\n# remDr$maxWindowSize() \n\nremDr$screenshot(file = \"output/ss/SICOP_Municipalidad.png\") # Tomar screenshot\n\nEl screenshot se vería de la siguiente forma:"
  },
  {
    "objectID": "posts/SICOP/index.html#utilización-de-loops-para-obtener-grandes-volúmenes-de-información",
    "href": "posts/SICOP/index.html#utilización-de-loops-para-obtener-grandes-volúmenes-de-información",
    "title": "Webscraping básico con RSelenium",
    "section": "3.1 Utilización de loops para obtener grandes volúmenes de información",
    "text": "3.1 Utilización de loops para obtener grandes volúmenes de información\nAl tener la estructura básica para obtener la información de una página web, es posible aplicar la misma fórmula para obtener grandes cantidades de información de la misma página web. Para esto es posible utilizar el loop for.\n\n# Ejemplo de utilización de un loop \"for\"\n\nfor (x in 1:10) { # Se brinda una secuencia la cual será seguida por la variable\n  print(x) # Se indica que devuelva el valor de la variable\n  # Al finalizar devolverá el siguiente valor que corresponde a la variable del loop\n}\n\nEn el caso estudiado si se obtiene una secuencia que implique toda la información que se desea obtener, es posible aplicar dicho loop para obtener la misma. Para esto es necesario analizar un poco la estructura de la página.\nSe puede realizar de diferentes formas pero en este caso se buscará el patrón para cada nodo donde se clickea para obtener información específica del concurso. Al analizar la secuencia de concursos se aprecia lo siguiente:\n\n# xpath para el primer concurso de la página\n\"/html/body/div[1]/div/div[2]/table[2]/tbody/tr[2]/td[2]/a[1]\"\n\n# xpath para el último concurso de la página\n\"/html/body/div[1]/div/div[2]/table[2]/tbody/tr[11]/td[2]/a[1]\"\n\nEl “tr[x]” aumenta en número según el concurso que corresponda. Asumiendo una página llena de concursos, tendríamos 10 concursos por página. No obstante si se desean obtener todos los concursos de todas las páginas, llegará el momento en que una de estas páginas no tendrá 10 concursos en la página; para evitar problemas con esto es posible buscar una condición que indique el número de concursos que hay por página.\nUn método para obtener la cantidad de concursos sería obtener la tabla de concursos y saber cuantos elementos hay en la misma. Para evitar el cambio entre frames, es posible utilizar el link directo al frame donde se encontrarían las tablas (este es un frame dentro del “mainFrame”). Este link puede obtenerse mediante el método utilizado en la explicación del cambio entre frames.\n\nremDr$switchToFrame(NA) # Si hay un frame enfocado, se quita el focus.\n\n# Se cambia al mainFrame\nremDr$switchToFrame(webElems[[1]]) # Se cambia al mainFrame\n\n# Se busca el identificador de los frames\nwebElems <- remDr$findElements(\"tag name\",\"frame\")\n\n# Se aprecian los enlaces de frames existentes, interesa el frame \"moduloOferta\"\n# Así que se guarda su valor en un string\nsapply(webElems, function(x){x$getElementAttribute(\"src\")})\n\nlink_tabla <- as.character(sapply(webElems, function(x){x$getElementAttribute(\"src\")})[2])\n\nObtenido el frame mencionado, ya no es necesario cambiar constantemente entre frames y con esto es posible ahorrar el espacio del código que pudo ser usado para ello. Ahora es posible realizar la misma búsqueda como la realizada en la primera sección.\n\n# Se realiza lo mismo que se realizó al inicio\n# Pero en este caso no es necesario cambiar entre frames\n\nremDr$switchToFrame(NA) # Si hay un frame enfocado, se quita el focus.\n\n# Página de SICOP para buscar concursos\n\nremDr$navigate('https://www.sicop.go.cr/moduloOferta/search/EP_SEJ_COQ600.jsp')\n\n# Se busca el identificador para la descripción de procedimiento\n\nDescProc <- remDr$findElement(\"name\", \"cartelNm\") \n\nDescProc$sendKeysToElement(list(\"Municipalidad\")) # Se escribe lo que interesa\n\n# Cambiar fecha\n\ndd <- \"01\" # Día\nmm <- \"01\" # Mes\naa <- \"2010\" # Año\n\nstrdate <- paste0(dd,mm,aa) # deben ser de tipo string o si no se borran los ceros\n\n# Se encuentra el cuadro de fecha con el xpath\n\nfecha <- remDr$findElement(\"xpath\", '//*[@id=\"regDtFrom\"]')\n\nfecha$clickElement() # Se clickea la fecha\nfecha$clearElement() # Se borra la fecha que está puesta por default\nfecha$sendKeysToElement(list(strdate)) # Se escribe lo que interesa\n\nremDr$findElement(\"xpath\",\"/html/body/div[1]/div/div[2]/form[1]/table/tbody/tr[12]/td/select/option[1]\")$clickElement() # Estado del concurso\n\n# Para consultar\n# Se hace una variable para con la consulta para facilitar el ejemplo\nConsultar <- remDr$findElement(\"xpath\", \"/html/body/div[1]/div/div[2]/p/span/a\") \nConsultar$clickElement() # Se hace click en consultar (por xpath)\n\nPara obtener el número de concursos para cada página es posible realizar lo siguiente:\n\nnum_pag <- read_html(remDr$getPageSource()[[1]]) %>% # se extrae numero de paginas\n  html_nodes(\"li a\") %>% # Se especifica lo que contiene el número de páginas\n  html_text() # se devuelve como texto\n\n# Se remueven los elementos en blanco\n\nnum_pag <- num_pag[num_pag != \"\"]\n\nLuego se plantea el loop para obtener todas las tablas por cada página del set de páginas (de la página 1 a la página 10 únicamente).\n\nrm(\"df0\",\"df1\",\"i\",\"df2\")\n\n# Inicio del loop\n\nfor (i in num_pag) {\n\n# Si existe el df \"df0\" no se hace nada (se enseña un mensaje)\n# Si no existe se crea un df en blanco con x cantidad de columnas\n  \nifelse(exists(\"df0\"),paste0(\"Procesando página \",i,\"...\"),\n       assign(\"df0\",data.frame(matrix(ncol = length(1:5),nrow = 0))))\n  \n  # Se lee el código fuente, se busca el nodo con xpath, se extrae la tabla\n  # Y se pasa a un objeto data frame\n  \n  df1 <- read_html(remDr$getPageSource()[[1]]) %>% \n    html_nodes(xpath = \"/html/body/div[1]/div/div[2]/table[2]\") %>%\n    html_table() %>%\n    as.data.frame()\n\n  # Se asignan nombres de columna del df1 al df0\n  colnames(df0) <- colnames(df1)\n\n  # Se combina el df en blanco y el df con datos\n  df0 <- rbind(df0,df1) #\n\n  # Se crea una nueva variable dado que el número de página no corresponde al número\n  # para pasar de página según el xpath\n  jj <- as.numeric(i)-1\n\n  # Si el número de página es mayor a 2, entonces antes de pasar de página se volverá a\n  # la página 1 antes de ir a la siguiente página (esto dado que el xpath cambia\n  # según la página en que se encuentre)\n  if (i > 2) {\n    remDr$goBack # Ir hacia la página anterior\n    remDr$findElement(\"xpath\", # Ir a la siguiente página\n                      paste0('//*[@id=\"paging\"]/ul/li/a[',jj,']'))$clickElement() \n  } else{\n    remDr$findElement(\"xpath\", # Ir a la siguiente página\n                      paste0('//*[@id=\"paging\"]/ul/li/a[',jj,']'))$clickElement()\n  }\n  \n}\n\nDespués de llegar al final del número de páginas que fueron obtenidas y almacenadas en la variable “num_pag”, es posible seguir con el siguiente set de páginas. Para esto es posible indicar que cuanto se termine el loop de un set de páginas, se pase al siguiente set de páginas y se obtenga nuevamente el número de páginas para el nuevo set. Al revisar los xpath para pasar al siguiente set de páginas se obtiene lo siguiente:\n\n\n'//*[@id=\"paging\"]/ul/li/a[10]' # xpath para pasar al segundo set de páginas\n\n'//*[@id=\"paging\"]/ul/li/a[12]' # xpath para pasar el resto de set de páginas\n\nExiste diferencia entre el xpath para pasar al segundo set de páginas y el que permite pasar el resto de set de páginas. Alternativamente, para evitar el uso de código adicional puede utilizarse un identificador de nombre en lugar de un xpath. El identificador de nombre para pasar de set de páginas en este caso es “page02” (se obtiene “inspeccionando” en el navegador). Entonces, pasar pasar cualquier set de páginas es posible realizar lo siguiente:\n\nremDr$findElement(\"class name\", \"page02\")$clickElement() # Click siguiente set de paginas\n\nAdemás de pasar de páginas, para realizar el loop es necesario cuando debe detenerse el mismo. Para esto es posible determinar la cantidad de set de páginas de antemano. Entonces es posible obtener el xpath que indica la cantidad máxima de páginas de los concursos. A no ser que exista un cambio mientras se obtiene la información, no sería necesario que este paso se encuentre adentro del loop.\n\n# se extrae numero de paginas\n\ntot_pags <- read_html(remDr$getPageSource()[[1]]) %>% \n  # Se especifica lo que contiene el número de páginas\n  html_nodes(xpath = '//*[@id=\"total\"]/span[3]') %>% \n  html_text() %>% \n  # Se pasa a numérico\n  as.numeric()\n\ntot_pags\n\nAhora se crea una variable que cambiará según la cantidad total de páginas. Esta ayudará a determinar cuando se detendrá el loop. Se divide entre 10 el número total de páginas y se divide hacia abajo el resultado; esto hará que al llegar a la última página, termine el loop\n\n# Se coloca nuevamente la asignación de esta variable para facilitar la comprensión de\n# donde proviene el \"set_pags\"\n\nset_pags <- ceiling(tot_pags/10) # Floor para redondear hacia arriba\nset_pags                         # Se visualiza el resultado\n\nEntonces, ya se posee suficiente código para ensamblar el loop, excepto que se realizará el mismo obteniendo mayores detalles de cada concurso (lo cual se realizó anteriormente). El fin es rla obtención de los detalles de cada concurso pero a lo largo de todas las páginas y sets de páginas existentes para el momento de ejecución del código. Para ello existiría una jerarquía de loops, de mayor a menos: una que itere sobre los sets de páginas, otra que itere sobre los números de página de los sets de páginas y otra que itere sobre cada elemento de tabla de la página.\n\n# Se coloca el xpath en dos variables para que al concatenarlas\n# sea posible colocar en medio la variable de iteración\n\nxp1 <- \"/html/body/div[1]/div/div[2]/table[2]/tbody/tr[\"\nxp2 <- \"]/td[2]/a[1]\"\n\nEntonces se procede a plantear el loop:\n\n# Loop para los sets de páginas\n\nfor (i in 1:set_pags) { \n  num_pag <- read_html(remDr$getPageSource()[[1]]) %>%\n    html_nodes(\"li a\") %>% \n    html_text()\n  num_pag <- num_pag[num_pag != \"\"]\n  num_pag <- length(num_pag)+1\n\n  # Loop para las páginas de un set\n\n  for (ii in 1:(max(num_pag))) { \n  \n    # Si el número de iteración es mayor a 1 entonces\n    # se pasará la página\n  \n    if (ii > 1){\n      remDr$findElement(\"xpath\",\n      paste0('//*[@id=\"paging\"]/ul/li/a[',ij,']'))$clickElement()\n    }\n  \n    # Se determina el número de concursos que tiene la tabla\n    # para la determinada página\n  \n    nrow_tab <- read_html(remDr$getPageSource()[[1]]) %>% \n      html_nodes(xpath = \"/html/body/div[1]/div/div[2]/table[2]\") %>%\n      html_table() %>%\n      as.data.frame() %>% \n      nrow() \n  \n    # Loop para los rows\n  \n    for (j in 1:nrow_tab) { \n      print(paste0(\"Scrapeando contenido del concurso \",j))\n      jj <- as.numeric(j) + 1\n      \n      # Se clickea en el elemento j de la tabla\n      \n      remDr$findElement(\"xpath\", paste0(xp1,jj,xp2))$clickElement()\n      \n      # Se obtiene el código y se guarda en una variable\n      \n      html <- read_html(remDr$getPageSource()[[1]]) %>% \n        html_nodes(xpath = \"/html/body/div/div/div[2]/table[3]\")\n      \n      # Se obtienen los nombres de columna\n      \n      nomb.column <- html %>%\n        html_nodes(\"th.epcthl\") %>%\n        html_text() %>% \n        str_trim(side = \"both\") %>%\n        str_squish() %>% \n        make.names()\n       \n      # Se obtiene el contenido\n        \n      contenido <- html %>% \n        html_nodes(\"td.eptdl\") %>%\n        html_text() %>% \n        str_trim(side = \"both\") %>% \n        str_squish()\n      \n      # Se realiza un df en blanco del largo de nomb.column\n      \n      assign(\"df0\",data.frame(matrix(ncol = length(nomb.column))))\n      \n      # Se asignan los nombres de columna\n      # Se asigna el contenido al df\n\n      colnames(df0) <- nomb.column\n      df0[nrow(df0),] <- contenido\n\n      # Si existe \"df_concursos\" se le agrega df0\n      # si no existe, df0 será df_concursos\n      \n      ifelse(exists(\"df_concursos\"),\n             assign(\"df_concursos\",bind_rows(df0, df_concursos)),\n             assign(\"df_concursos\", df0))\n      \n      # Se remueven las variables innecesarias\n      \n      rm(df0,nomb.column,contenido,html)\n      \n      # Se vuelve a la página anterior\n      \n      remDr$goBack()\n    }\n  \n    # Si el set de páginas es mayor a 1 el numero para hacer click en xpath\n    # cambia y aumenta de 1 (en el primer set es 1 para la pagina 2) a 3 y\n    # por esta razón después de que el set de páginas es mayor a 1, se suma 2\n\n    if (i > 1) { \n      ij <- ii+2\n      } else{\n      ij <- ii\n      }\n  }\n\n# Si i (set de páginas) es igual a \"set_pags\" entonces\n# el webscrape terminó. De lo contrario dará click\n# en el siguiente set de páginas\n\nif (i == set_pags) {\n  print(\"Webscrape terminado\")\n  } else{\n\n    # Para pasar el set de    \n    remDr$findElement(\"class name\", \"page02\")$clickElement() \n  }\n}\n\nEl resultado es un data frame con los detalles de los concursos publicados en SICOP que están relacionados con la palabra “Municipalidad” y que aun se encuentran o no en recepción de ofertas. La tabla debería lucir similar a la siguiente:"
  }
]