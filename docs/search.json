[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R, Geografía y Data",
    "section": "",
    "text": "Representación de datos\n\n\n\n\n\n\n\nSIG\n\n\n\n\n\n\n\n\n\n\n\nMar 23, 2024\n\n\nGabriel Ramírez\n\n\n\n\n\n\n  \n\n\n\n\nLimpieza de datos scrapeados con R\n\n\n\n\n\n\n\nWebscraping\n\n\nRSelenium\n\n\nlimpieza de datos\n\n\n\n\n\n\n\n\n\n\n\nMar 10, 2024\n\n\nGabriel Ramírez\n\n\n\n\n\n\n  \n\n\n\n\nWebscraping básico con RSelenium\n\n\n\n\n\n\n\nWebscraping\n\n\nRSelenium\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nDec 23, 2022\n\n\nGabriel Ramírez\n\n\n\n\n\n\n  \n\n\n\n\nWebscrape de puntos de Open Street Map (OSM)\n\n\n\n\n\n\n\nSIG\n\n\n\n\n\n\n\n\n\n\n\nApr 2, 2022\n\n\nGabriel Ramírez\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/SICOP/index.html",
    "href": "posts/SICOP/index.html",
    "title": "Webscraping básico con RSelenium",
    "section": "",
    "text": "En este proyecto se obtienen datos del Sistema Integrado de Compras Públicas (SICOP) por municipalidad. El fin es realizar un análisis descriptivo y espacializar los datos por municipalidad o institución (cantón o localización de municipalidad).\nEste sistema se autodenomina como una novedosa herramienta para la realización de negocios vía web. De forma más específica, permite a las proveedurías del Estado realizar compra y venta de servicios y productos de forma electrónica.\nEste modelo de compras se realizó tras un análisis de prácticas efectuadas por países como Chile, Panamá, México, Brasil y Corea. Dicho estudio finalizó con la adopción del modelo de Corea del Sur, por ser lider mundial en esta temática (compras electrónicas); mediante su sistema de gestión denominado Korea On Line e-Procurement System (Koneps), definido como el ‘marketplace’ más grande del mundo. Este modelo, mencionan en información de SICOP (SICOP, 2015)."
  },
  {
    "objectID": "posts/SICOP/index.html#carga-de-librerías-y-directorio-de-trabajo",
    "href": "posts/SICOP/index.html#carga-de-librerías-y-directorio-de-trabajo",
    "title": "Webscraping básico con RSelenium",
    "section": "Carga de librerías y directorio de trabajo",
    "text": "Carga de librerías y directorio de trabajo\nEl directorio de trabajo depende de donde se encuentre el archivo de trabajo.\n\nsetwd(\"~/GitHub/R-Geografia-y-Data/posts/SICOP/\") # Directorio de trabajo\n\n# Paquetes a utilizar\n\nlibrary(RSelenium)\nlibrary(tidyverse)\nlibrary(rvest)\nlibrary(xml2)\nlibrary(stringi)\nlibrary(seleniumPipes)\nlibrary(XML)\nlibrary(knitr)\nlibrary(kableExtra)\nlibrary(netstat) # Para el free_port()"
  },
  {
    "objectID": "posts/SICOP/index.html#inicio-del-server-de-selenium-y-el-navegador",
    "href": "posts/SICOP/index.html#inicio-del-server-de-selenium-y-el-navegador",
    "title": "Webscraping básico con RSelenium",
    "section": "Inicio del server de selenium y el navegador",
    "text": "Inicio del server de selenium y el navegador\nEs posible elaborar un código para conocer cuales son las ofertas que se encuentran en etapa de recepción de ofertas en el SICOP. Dada la estructura de la página se utiliza la libreria RSelenium en lugar de rvest. Esto dado que se trata de un sitio web interactivo.\nSe puede iniciar con la creación de un servidor para navegar.\n\n# Este script permite obtener los concursos de \n# municipalidades que se encuentran en la etapa de recepción de ofertas\n\n# Empezar el servidor\nrs_driver_object <- rsDriver(browser = 'chrome', # Se utilizará Google Chrome\n                             chromever = '108.0.5359.71', # Versión de Chrome\n                             verbose = FALSE, # No incluir mensajes de estado\n                             port = free_port(), # Se utiliza un puerto libre\n                             check = TRUE) # Checar si hay nuevas versiones\n\nDespués de la creación del servidor, se puede crear un objeto cliente y se asigna a una variable. También se abre el navegador y la página web de SICOP.\n\n# crear un objeto cliente\nremDr <- rs_driver_object$client\n\n# Se navega a la página de interés\n\nremDr$navigate('https://www.sicop.go.cr/index.jsp') # \n\nAl estar en la página web interesa irse a la sección de la misma en donde se encuentra la información de los concursos actuales. La página web principal de SICOP se conforma por dos frames. Esto se sabe dado que al inspeccionar el código fuente de la página, se aprecia lo siguiente:\n</head>\n    <frameset rows=\"125,*\" cols=\"*\"  onunload=\"javascript:confirmClose();\" >\n        <frame src=\"/portal/fm/PT_FMJ_TFQ001.jsp?user_cls=\" frameborder=\"0\"  name=\"topFrame\" id=\"topFrame\"  scrolling=\"no\" noresize>\n        <frame src=\"/portal/fm/PT_FMJ_MFQ001.jsp?user_cls=\" frameborder=\"0\"  name=\"mainFrame\" id=\"mainFrame\" scrolling=\"yes\">\n    </frameset>\n</html>\nEntonces, al conocer que el botón para la consulta de los concursos se encuentra en el primer frame, para poder clickearlo sería necesario hacerle énfasis al mismo. Para ello es posible extraer mediante tag name todos los elementos que coincidan con la palabra frame.\n\n# Se busca el identificador de los frames\n\nwebElems <- remDr$findElements(\"tag name\",\"frame\")\n\n# Se aprecian los enlaces de frames existentes\n\nsapply(webElems, function(x){x$getElementAttribute(\"src\")})\n\nAl obtener todos los elementos con tag name de nombre frame podemos apreciar que existen dos frames, los cuales corresponden al topFrame y al middleFrame.\n\n\"https://www.sicop.go.cr/portal/fm/PT_FMJ_TFQ001.jsp?user_cls=\"\n\"https://www.sicop.go.cr/portal/fm/PT_FMJ_MFQ001.jsp?user_cls=\"\n\nAl comprobar cual de los dos frames corresponde al frame donde se encuentra la opción para buscar los concursos, se selecciona el mismo (recordar que se guardaron los frames en la variable webElems, entonces nada más se selecciona el frame de arriba o topFrame)\nYa seleccionado el frame que nos interesa, es posible hacer click en sus elementos. En este caso se realiza click en la pestaña de concursos. Para ello se utiliza el xpath el cual se puede obtener con la opción de “inspeccionar elemento” que ofrecen algunos navegadores.\n\n# Se cambia al frame 1 (topFrame)\n\nremDr$switchToFrame(webElems[[1]])\n\n# Se busca el elemento de interés e inmediatamente se clickea el mismo\n# Se especifica el método de búsqueda y se coloca el identificador\n# luego se indica dar click en el elemento\n\nremDr$findElement(\"xpath\", \n                  \"/html/body/div[2]/div/div/div[4]/ul/li[2]/div[1]/a[3]\")$clickElement()\n\nAl estar en la página donde se colocan los parámetros de búsqueda, es posible continuar. No obstante, recordar que hicimos enfoque a un frame específico de la página. De acuerdo a la documentación únicamente debemos utilizar la misma función pero asignarle NULL en el argumento; a pesar de estar en la documentación dicho método no funciona y es necesario colocar NA en lugar de NULL para regresar al frame principal.\n\nremDr$switchToFrame(NA) #\n\n# Se busca el identificador de los frames\n\nwebElems <- remDr$findElements(\"tag name\",\"frame\")\n\n# Se aprecian los enlaces de frames existentes\n\nsapply(webElems, function(x){x$getElementAttribute(\"src\")})\n\nApreciamos nuevamente que existen dos frames, pero al analizar la estructura de la página, vemos que el frame con los parámetros para buscar se encuentran en el segundo frame. Para ello se selecciona el mainFrame y en el mainFrame se selecciona el rightFrame.\nAdemás, se desea buscar todos los resultados que tengan la palabra “Municipalidad” en su texto. Para esto se busca y selecciona el cuadro donde se escribe y se coloca el texto.\n\nwebElems <- remDr$findElements(\"name\",\"mainFrame\")\nremDr$switchToFrame(webElems[[1]])\nwebElems2 <- remDr$findElements(\"name\",\"rightFrame\")\nremDr$switchToFrame(webElems2[[1]])\n\n# Se busca el identificador para la descripción de procedimiento\n\nDescProc <- remDr$findElement(\"name\", \"cartelNm\") \n\nDescProc$sendKeysToElement(list(\"Municipalidad\")) # Se escribe lo que interesa\n\nSi se desea cambiar la fecha de búsqueda es posible realizarlo de la siguiente manera. Específicamente, se cambia la fecha de rangos de publicación, mientras que la fecha máxima usualmente corresponde al día en que se consulte."
  },
  {
    "objectID": "posts/SICOP/index.html#llenado-de-formularios",
    "href": "posts/SICOP/index.html#llenado-de-formularios",
    "title": "Webscraping básico con RSelenium",
    "section": "Llenado de formularios",
    "text": "Llenado de formularios\n\n# Cambiar fecha\n\ndd <- \"01\" # Día\nmm <- \"01\" # Mes\naa <- \"2010\" # Año\n\nstrdate <- paste0(dd,mm,aa)\n\n# Se encuentra el cuadro de fecha con el xpath\n\nfecha <- remDr$findElement(\"xpath\", '//*[@id=\"regDtFrom\"]')\n\n# Se clickea la fecha\nfecha$clickElement() \n\n# Se borra la fecha que está puesta por default\nfecha$clearElement() \n\n# Se escribe lo que interesa\nfecha$sendKeysToElement(list(strdate)) \n\nEnseguida, se busca la opción de “Estado del Concurso” mediante su xpath, el cual se obtiene desde el navegador. Se selecciona la opción “Todos”\n\n# Estado del concurso\nremDr$findElement(\"xpath\",\n                  \"/html/body/div[1]/div/div[2]/form[1]/table/tbody/tr[12]/td/select/option[1]\")$clickElement()"
  },
  {
    "objectID": "posts/SICOP/index.html#obtención-de-información-tabulada",
    "href": "posts/SICOP/index.html#obtención-de-información-tabulada",
    "title": "Webscraping básico con RSelenium",
    "section": "Obtención de información tabulada",
    "text": "Obtención de información tabulada\nFinalmente, para realizar la búsqueda se realiza click al cuadro de consultar especificando mediante su xpath\n\n# Para consultar\n# Se hace una variable para con la consulta para facilitar el ejemplo\nConsultar <- remDr$findElement(\"xpath\", \"/html/body/div[1]/div/div[2]/p/span/a\") \n\n# Se hace click en consultar (por xpath)\nConsultar$clickElement() \n\nAl realizar la búsqueda se aprecia que los contenidos se encuentran en una tabla y además existe una cantidad de páginas con más tablas. Si se desea obtener todo el contenido de todas las páginas entonces el objetivo es la obtención de todas las tablas por cada páginas.\nSin embargo para comprender como funciona la obtención de información, se puede realizar por pasos. Para obtener la primera tabla se puede realizar lo siguiente:\n\nread_html(remDr$getPageSource()[[1]]) %>% \n  html_nodes(xpath = \"/html/body/div[1]/div/div[2]/table[2]\") %>% \n  html_table(trim = T)\n\nY al ejecutar el código se obtiene un resultado similar al siguiente:\n\n\n\n\n \n  \n    Número.de.procedimiento.Nombre.de.la.institución \n    Descripción.del.procedimiento \n    Fecha.hora.depublicación \n    Fecha.hora.deapertura \n    Estado.del.concurso \n  \n \n\n  \n    2022CD-000040-0004300001MUNICIPALIDAD DE CORREDORES \n    [CD] CONTRATACIÓN DE REPUESTOS Y SERVICIOS DE MANTENIMIENTO PARA VEHÍCULO SM-4770 DE LA MUNICIPALIDAD DE CORREDORES Encargado de publicación, gestión de objeciones y apertura: REYMOND GONZALEZ ZUÑIGA \n    22/12/2022 10:13 \n    23/12/2022 12:01 \n    En recepción de ofertas \n  \n  \n    2022CD-000242-0002200001MUNICIPALIDAD DE MORA \n    [CD] COMPRA DE CALZADO PARA LOS CUERPOS POLICIALES DE LA MUNICIPALIDAD DE MORA Encargado de publicación, gestión de objeciones y apertura : GEREMMY DE LOS ANGELES CHAVES MARIN \n    21/12/2022 10:51 \n    23/12/2022 14:00 \n    En recepción de ofertas \n  \n  \n    2022LD-000003-0003100001Municipalidad de Puntarenas \n    [LD] CONTRATACIÓN DE SERVICIOS PROFESIONALES PARA LA ELABORACION DE LOS MANUALES DE PROCEDIMIENTOS FINANCIERO CONTABLES DE LA MUNICIPALIDAD DE PUNTARENAS Encargado de publicación, gestión de objeciones y apertura : LUIS EDWARD ROJAS BARRANTES \n    21/12/2022 09:33 \n    23/12/2022 15:00 \n    En recepción de ofertas \n  \n  \n    2022CD-000204-0002300005Municipalidad de Sarapiquí \n    [CD] CONTRATACIÓN DE SERVICIOS AUXILIARES PARA DEPARTAMENTO DE BIENES INMUEBLES DE LA MUNICIPALIDAD DE SARAPIQUI Encargado de publicación, gestión de objeciones y apertura : ELVIN HERNANDEZ LORIA \n    20/12/2022 17:45 \n    22/12/2022 12:00 \n    En apertura \n  \n  \n    2022CD-000203-0002300005Municipalidad de Sarapiquí \n    [CD] Solicitud de contratación de servicios auxiliares para el departamento de plataforma de servicios de la Municipalidad de Sarapiquí. Encargado de publicación, gestión de objeciones y apertura : ADILIA SANCHEZ MONTOYA \n    20/12/2022 16:01 \n    22/12/2022 12:00 \n    En apertura \n  \n\n\n\n\n\n\n\n\n\n\n\nNota\n\n\n\nÚnicamente se colocan 5 elementos para facilitar la visibilidad. El código podría devolver más o menos concursos según los parámetros de búsqueda o la misma existencia de concursos."
  },
  {
    "objectID": "posts/SICOP/index.html#capturas-de-pantalla",
    "href": "posts/SICOP/index.html#capturas-de-pantalla",
    "title": "Webscraping básico con RSelenium",
    "section": "Capturas de pantalla",
    "text": "Capturas de pantalla\nDicha tabla correspondería al contenido de tabla actual de la página web de SICOP. De igual forma puede realizarse un “screenshot” el contenido actual de la página de la siguiente manera:\n\n# Si usas esta opción, la pestaña se maximiza y el screnshot abarcará más área\n# remDr$maxWindowSize() \n\nremDr$screenshot(file = \"output/ss/SICOP_Municipalidad.png\")\n\nEl screenshot se vería de la siguiente forma:"
  },
  {
    "objectID": "posts/SICOP/index.html#utilización-de-loops-para-obtener-grandes-volúmenes-de-información",
    "href": "posts/SICOP/index.html#utilización-de-loops-para-obtener-grandes-volúmenes-de-información",
    "title": "Webscraping básico con RSelenium",
    "section": "Utilización de loops para obtener grandes volúmenes de información",
    "text": "Utilización de loops para obtener grandes volúmenes de información\nAl tener la estructura básica para obtener la información de una página web, es posible aplicar la misma fórmula para obtener grandes cantidades de información de la misma página web. Para esto es posible utilizar el loop for.\n\n# Ejemplo de utilización de un loop \"for\"\n\nfor (x in 1:10) { # Se brinda una secuencia la cual será seguida por la variable\n  print(x) # Se indica que devuelva el valor de la variable\n  # Al finalizar devolverá el siguiente valor que corresponde a la variable del loop\n}\n\nEn el caso estudiado si se obtiene una secuencia que implique toda la información que se desea obtener, es posible aplicar dicho loop para obtener la misma. Para esto es necesario analizar un poco la estructura de la página.\nSe puede realizar de diferentes formas pero en este caso se buscará el patrón para cada nodo donde se clickea para obtener información específica del concurso. Al analizar la secuencia de concursos se aprecia lo siguiente:\n\n# xpath para el primer concurso de la página\n\"/html/body/div[1]/div/div[2]/table[2]/tbody/tr[2]/td[2]/a[1]\"\n\n# xpath para el último concurso de la página\n\"/html/body/div[1]/div/div[2]/table[2]/tbody/tr[11]/td[2]/a[1]\"\n\nEl tr[x] aumenta en número según el concurso que corresponda. Asumiendo una página llena de concursos, tendríamos 10 concursos por página. No obstante si se desean obtener todos los concursos de todas las páginas, llegará el momento en que una de estas páginas no tendrá 10 concursos en la página; para evitar problemas con esto es posible buscar una condición que indique el número de concursos que hay por página.\nUn método para obtener la cantidad de concursos sería obtener la tabla de concursos y saber cuantos elementos hay en la misma. Para evitar el cambio entre frames, es posible utilizar el link directo al frame donde se encontrarían las tablas (este es un frame dentro del mainFrame). Este link puede obtenerse mediante el método utilizado en la explicación del cambio entre frames.\n\nremDr$switchToFrame(NA) # Si hay un frame enfocado, se quita el focus.\n\n# Se cambia al mainFrame\nremDr$switchToFrame(webElems[[1]]) # Se cambia al mainFrame\n\n# Se busca el identificador de los frames\nwebElems <- remDr$findElements(\"tag name\",\"frame\")\n\n# Se aprecian los enlaces de frames existentes, interesa el frame \"moduloOferta\"\n# Así que se guarda su valor en un string\nsapply(webElems, function(x){x$getElementAttribute(\"src\")})\n\nlink_tabla <- as.character(sapply(webElems, function(x){x$getElementAttribute(\"src\")})[2])\n\nObtenido el frame mencionado, ya no es necesario cambiar constantemente entre frames y con esto es posible ahorrar el espacio del código que pudo ser usado para ello. Ahora es posible realizar la misma búsqueda como la realizada en la primera sección.\n\n# Se realiza lo mismo que se realizó al inicio\n# Pero en este caso no es necesario cambiar entre frames\n\nremDr$switchToFrame(NA) # Si hay un frame enfocado, se quita el focus.\n\n# Página de SICOP para buscar concursos\n\nremDr$navigate('https://www.sicop.go.cr/moduloOferta/search/EP_SEJ_COQ600.jsp')\n\n# Se busca el identificador para la descripción de procedimiento\n\nDescProc <- remDr$findElement(\"name\", \"cartelNm\") \n\nDescProc$sendKeysToElement(list(\"Municipalidad\"))\n\n# Cambiar fecha\n\ndd <- \"01\" # Día\nmm <- \"01\" # Mes\naa <- \"2010\" # Año\n\nstrdate <- paste0(dd,mm,aa)\n\n# Se encuentra el cuadro de fecha con el xpath\nfecha <- remDr$findElement(\"xpath\", '//*[@id=\"regDtFrom\"]')\n\nfecha$clickElement()\nfecha$clearElement()\nfecha$sendKeysToElement(list(strdate))\n\nremDr$findElement(\"xpath\",\"/html/body/div[1]/div/div[2]/form[1]/table/tbody/tr[12]/td/select/option[1]\")$clickElement()\n\n# Para consultar\n# Se hace una variable para con la consulta para facilitar el ejemplo\nConsultar <- remDr$findElement(\"xpath\", \"/html/body/div[1]/div/div[2]/p/span/a\") \nConsultar$clickElement() \n\nPara obtener el número de concursos para cada página es posible realizar lo siguiente:\n\n# se extrae numero de paginas\nnum_pag <- read_html(remDr$getPageSource()[[1]]) %>%\n  # Se especifica lo que contiene el número de páginas\n  html_nodes(\"li a\") %>% \n  html_text() \n\n# Se remueven los elementos en blanco\nnum_pag <- num_pag[num_pag != \"\"]\n\nLuego se plantea el loop para obtener todas las tablas por cada página del set de páginas (de la página 1 a la página 10 únicamente).\n\nrm(\"df0\",\"df1\",\"i\",\"df2\")\n\n# Inicio del loop\n\nfor (i in num_pag) {\n\n# Si existe el df \"df0\" no se hace nada (se enseña un mensaje)\n# Si no existe se crea un df en blanco con x cantidad de columnas\n  \nifelse(exists(\"df0\"),paste0(\"Procesando página \",i,\"...\"),\n       assign(\"df0\",data.frame(matrix(ncol = length(1:5),nrow = 0))))\n  \n  # Se lee el código fuente, se busca el nodo con xpath, se extrae la tabla\n  # Y se pasa a un objeto data frame\n  \n  df1 <- read_html(remDr$getPageSource()[[1]]) %>% \n    html_nodes(xpath = \"/html/body/div[1]/div/div[2]/table[2]\") %>%\n    html_table() %>%\n    as.data.frame()\n\n  # Se asignan nombres de columna del df1 al df0\n  colnames(df0) <- colnames(df1)\n\n  # Se combina el df en blanco y el df con datos\n  df0 <- rbind(df0,df1) #\n\n  # Se crea una nueva variable dado que el número de página no corresponde al número\n  # para pasar de página según el xpath\n  jj <- as.numeric(i)-1\n\n  # Si el número de página es mayor a 2, entonces antes de pasar de página se volverá a\n  # la página 1 antes de ir a la siguiente página (esto dado que el xpath cambia\n  # según la página en que se encuentre)\n  if (i > 2) {\n    remDr$goBack # Ir hacia la página anterior\n    remDr$findElement(\"xpath\", # Ir a la siguiente página\n                      paste0('//*[@id=\"paging\"]/ul/li/a[',jj,']'))$clickElement() \n  } else{\n    remDr$findElement(\"xpath\", # Ir a la siguiente página\n                      paste0('//*[@id=\"paging\"]/ul/li/a[',jj,']'))$clickElement()\n  }\n  \n}\n\nDespués de llegar al final del número de páginas que fueron obtenidas y almacenadas en la variable “num_pag”, es posible seguir con el siguiente set de páginas. Para esto es posible indicar que cuanto se termine el loop de un set de páginas, se pase al siguiente set de páginas y se obtenga nuevamente el número de páginas para el nuevo set. Al revisar los xpath para pasar al siguiente set de páginas se obtiene lo siguiente:\n\n\n# xpath para pasar al segundo set de páginas\n'//*[@id=\"paging\"]/ul/li/a[10]' \n\n# xpath para pasar el resto de set de páginas\n'//*[@id=\"paging\"]/ul/li/a[12]' \n\nExiste diferencia entre el xpath para pasar al segundo set de páginas y el que permite pasar el resto de set de páginas. Alternativamente, para evitar el uso de código adicional puede utilizarse un identificador de nombre en lugar de un xpath. El identificador de nombre para pasar de set de páginas en este caso es “page02” (se obtiene “inspeccionando” en el navegador). Entonces, pasar pasar cualquier set de páginas es posible realizar lo siguiente:\n\n# Click siguiente set de paginas\n\nremDr$findElement(\"class name\", \"page02\")$clickElement() \n\nAdemás de pasar de páginas, para realizar el loop es necesario cuando debe detenerse el mismo. Para esto es posible determinar la cantidad de set de páginas de antemano. Entonces es posible obtener el xpath que indica la cantidad máxima de páginas de los concursos. A no ser que exista un cambio mientras se obtiene la información, no sería necesario que este paso se encuentre adentro del loop.\n\n# se extrae numero de paginas\n\ntot_pags <- read_html(remDr$getPageSource()[[1]]) %>% \n  # Se especifica lo que contiene el número de páginas\n  html_nodes(xpath = '//*[@id=\"total\"]/span[3]') %>% \n  html_text() %>% \n  # Se pasa a numérico\n  as.numeric()\n\ntot_pags\n\nAhora se crea una variable que cambiará según la cantidad total de páginas. Esta ayudará a determinar cuando se detendrá el loop. Se divide entre 10 el número total de páginas y se divide hacia abajo el resultado; esto hará que al llegar a la última página, termine el loop\n\n# Se coloca nuevamente la asignación de esta variable para facilitar la comprensión de\n# donde proviene el \"set_pags\"\n\nset_pags <- ceiling(tot_pags/10) # Floor para redondear hacia arriba\nset_pags                         # Se visualiza el resultado\n\nEntonces, ya se posee suficiente código para ensamblar el loop, excepto que se realizará el mismo obteniendo mayores detalles de cada concurso (lo cual se realizó anteriormente). El fin es la obtención de los detalles de cada concurso pero a lo largo de todas las páginas y sets de páginas existentes para el momento de ejecución del código. Para ello existiría una jerarquía de loops, de mayor a menos: una que itere sobre los sets de páginas, otra que itere sobre los números de página de los sets de páginas y otra que itere sobre cada elemento de tabla de la página.\n\n# Se coloca el xpath en dos variables para que al concatenarlas\n# sea posible colocar en medio la variable de iteración\n\nxp1 <- \"/html/body/div[1]/div/div[2]/table[2]/tbody/tr[\"\nxp2 <- \"]/td[2]/a[1]\"\n\nEntonces se procede a plantear el loop:\n\n# Loop para los sets de páginas\n\nfor (i in 1:set_pags) { \n  num_pag <- read_html(remDr$getPageSource()[[1]]) %>%\n    html_nodes(\"li a\") %>% \n    html_text()\n  num_pag <- num_pag[num_pag != \"\"]\n  num_pag <- length(num_pag)+1\n\n  # Loop para las páginas de un set\n\n  for (ii in 1:(max(num_pag))) { \n  \n    # Si el número de iteración es mayor a 1 entonces\n    # se pasará la página\n  \n    if (ii > 1){\n      remDr$findElement(\"xpath\",\n      paste0('//*[@id=\"paging\"]/ul/li/a[',ij,']'))$clickElement()\n    }\n  \n    # Se determina el número de concursos que tiene la tabla\n    # para la determinada página\n  \n    nrow_tab <- read_html(remDr$getPageSource()[[1]]) %>% \n      html_nodes(xpath = \"/html/body/div[1]/div/div[2]/table[2]\") %>%\n      html_table() %>%\n      as.data.frame() %>% \n      nrow() \n  \n    # Loop para los rows\n  \n    for (j in 1:nrow_tab) { \n      print(paste0(\"Scrapeando contenido del concurso \",j))\n      jj <- as.numeric(j) + 1\n      \n      # Se clickea en el elemento j de la tabla\n      \n      remDr$findElement(\"xpath\", paste0(xp1,jj,xp2))$clickElement()\n      \n      # Se obtiene el código y se guarda en una variable\n      \n      html <- read_html(remDr$getPageSource()[[1]]) %>% \n        html_nodes(xpath = \"/html/body/div/div/div[2]/table[3]\")\n      \n      # Se obtienen los nombres de columna\n      \n      nomb.column <- html %>%\n        html_nodes(\"th.epcthl\") %>%\n        html_text() %>% \n        str_trim(side = \"both\") %>%\n        str_squish() %>% \n        make.names()\n       \n      # Se obtiene el contenido\n        \n      contenido <- html %>% \n        html_nodes(\"td.eptdl\") %>%\n        html_text() %>% \n        str_trim(side = \"both\") %>% \n        str_squish()\n      \n      # Se realiza un df en blanco del largo de nomb.column\n      \n      assign(\"df0\",data.frame(matrix(ncol = length(nomb.column))))\n      \n      # Se asignan los nombres de columna\n      # Se asigna el contenido al df\n\n      colnames(df0) <- nomb.column\n      df0[nrow(df0),] <- contenido\n\n      # Si existe \"df_concursos\" se le agrega df0\n      # si no existe, df0 será df_concursos\n      \n      ifelse(exists(\"df_concursos\"),\n             assign(\"df_concursos\",bind_rows(df0, df_concursos)),\n             assign(\"df_concursos\", df0))\n      \n      # Se remueven las variables innecesarias\n      \n      rm(df0,nomb.column,contenido,html)\n      \n      # Se vuelve a la página anterior\n      \n      remDr$goBack()\n    }\n  \n    # Si el set de páginas es mayor a 1 el numero para hacer click en xpath\n    # cambia y aumenta de 1 (en el primer set es 1 para la pagina 2) a 3 y\n    # por esta razón después de que el set de páginas es mayor a 1, se suma 2\n\n    if (i > 1) { \n      ij <- ii+2\n      } else{\n      ij <- ii\n      }\n  }\n\n# Si i (set de páginas) es igual a \"set_pags\" entonces\n# el webscrape terminó. De lo contrario dará click\n# en el siguiente set de páginas\n\nif (i == set_pags) {\n  print(\"Webscrape terminado\")\n  } else{\n\n    # Para pasar el set de    \n    remDr$findElement(\"class name\", \"page02\")$clickElement() \n  }\n}\n\nEl resultado es un data frame con los detalles de los concursos publicados en SICOP que están relacionados con la palabra “Municipalidad” y que aun se encuentran o no en recepción de ofertas. La tabla debería lucir similar a la siguiente (solo se muestran algunos resultados para facilitar la visualización):\n\n\n\n\n \n  \n    Funcionarios.relacionados \n    Estado.del.concurso \n    Fecha.hora.de.publicación \n    Cartel \n    Número.de.procedimiento \n    Número.de.SICOP \n    Nombre.de.la.institución \n    Concurso.confidencial \n    Encargado.de.publicación..gestión.de.objeciones.y.apertura \n    Elaborador \n    Encargado.de.solicitar.estudio.de.ofertas.recomendación.del.acto.final \n    Registro.del.pliego.de.condiciones \n    Versiones.del.cartel \n    Versión.en.consulta \n    Descripción.del.procedimiento \n    Clasificación.del.objeto \n    Tipo.de.procedimiento \n    Tipo.de.modalidad \n    Tipo.de.recepción.de.ofertas \n    Lugar.de.apertura \n    Inicio.de.recepción.de.ofertas \n    Cierre.de.recepción.de.ofertas \n    Fecha.hora.de.apertura.de.ofertas \n    Plazo.del.acto.final \n    Presupuesto.total.estimado \n    Presupuesto.total.estimado.USD..Opcional. \n    Fundamento.jurídico \n  \n \n\n  \n    Funcionarios relacionados con el concurso \n    En evaluación \n    02/05/2022 15:25 \n    Real \n    2022LN-000001-0021700001 \n    - \n    Municipalidad de Heredia \n    No \n    Enio Vargas Arrieta \n    Enio Vargas Arrieta \n    Enio Vargas Arrieta \n    Modificar \n    20220402880-01 20220402880-02 20220402880-03 20220402880-04 20220402880-05 20220402880-06 20220402880-07 \n    20220402880-00 \n    CONTRATACION PARA SUMINISTRO MEZCLA ASFALTICA EN CARPETAS Y OTROS EN CUMPLIMIENTO POR DEMANDA PARA LA MUNICIPALIDAD DE HEREDIA \n    BIENES \n    LICITACIÓN PÚBLICA NACIONAL \n    Según demanda \n    En línea \n    https://www.sicop.go.cr \n    04/08/2022 07:00 \n    08/08/2022 10:00 \n    08/08/2022 10:00 \n    60 Días hábiles \n    283.767,29 [CRC] \n     \n    NA \n  \n  \n    Funcionarios relacionados con el concurso \n    Adjudicación en firme \n    07/06/2022 14:53 \n    Real \n    2022LA-000001-0003100001 \n    - \n    Municipalidad de Puntarenas \n    No \n    LUIS EDWARD ROJAS BARRANTES \n    LUIS EDWARD ROJAS BARRANTES \n    LUIS EDWARD ROJAS BARRANTES \n    Modificar \n    20220600067-01 20220600067-02 20220600067-03 20220600067-04 20220600067-05 \n    20220600067-00 \n    ADQUISICION DE UNIFORMES PARA LOS FUNCIONARIOS DE LA MUNICIPALIDAD DE PUNTARENAS, BAJO LA MODALIDAD DE ENTREGA SEGÚN DEMANDA POR UN PERIODO DE CUATRO AÑOS. \n    BIENES \n    LICITACIÓN ABREVIADA \n    Según demanda \n    En línea \n    https://www.sicop.go.cr \n    07/06/2022 15:00 \n    31/08/2022 15:00 \n    31/08/2022 15:00 \n    20 Días hábiles \n    17.746.000 [CRC] \n     \n    NA \n  \n  \n    Funcionarios relacionados con el concurso \n    Contrato \n    06/07/2022 09:12 \n    Real \n    2022LA-000001-0021300211 \n    - \n    Municipalidad de Zarcero \n    No \n    MARIA VANESSA SALAZAR HUERTAS \n    MARIA VANESSA SALAZAR HUERTAS \n    MARIA VANESSA SALAZAR HUERTAS \n    Modificar \n    20220700524-01 20220700524-02 \n    20220700524-00 \n    Adquisición de servicio para elaboración Plan conservación, desarrollo y seguridad vial Red vial (Plan Quinquenal), Municipalidad de Zarcero \n    SERVICIOS \n    LICITACIÓN ABREVIADA \n    Servicios \n    En línea \n    https://www.sicop.go.cr \n    07/07/2022 08:00 \n    03/08/2022 08:45 \n    03/08/2022 09:00 \n    24 Días hábiles \n    24.000.000 [CRC] \n     \n    NA"
  },
  {
    "objectID": "posts/SICOP_Limpieza/index.html",
    "href": "posts/SICOP_Limpieza/index.html",
    "title": "Limpieza de datos scrapeados con R",
    "section": "",
    "text": "La limpieza y/o preparación de datos es una parte esencial del análisis estadístico. Usualmente esto toma más tiempo que el análisis estadístico como tal; usualmente en los ejercicios y ejemplos de análisis estadísticos se asume que los datos tienen una estructura adecuada para el análisis pero en la práctica suele ser necesario preparar el set de datos antes de realizar un análisis a los mismos (Jonge & Loo, 2013).\nUn set de datos técnicamente correcto se entiende como uno en el que cada valor: se puede reconocer que pertenece a cierta variable, es almacenado en un tipo de dato que representa el dominio de valores de la variable en la vida real; es decir, para cada tipo de valor, su variable debe pertenecer a su tipo adecuado (una de texto a una de texto, una numérica a una numérica, etc…). Jonge & Loo (2013) define un set de datos técnicamente correcto como un set en el que: es almacenada en un data.frame con columnas adecuadas y cada columna del data.frame es de un tipo que representa adecuadamente el dominio de valores de su variable.\nEl contenido de un set de datos podría ser no consistente, lo cual puede devenir en errores de análisis. Entre los posibles errores se encuentra el hecho de escribir la misma palabra de formas diferentes, la codificación del texto (por ejemplo, UTF-8), valores faltantes, outliers, valores especiales e incluso espacios en blanco innecesarios en una palabra o oración.\nPara lograr la consistencia en la data es posible: detectar las inconsistencias, seleccionar los campos que causan las inconsistencias y la corrección de estos campos ya sea mediante métodos determinísticos (modelos) o estocásticos."
  },
  {
    "objectID": "posts/SICOP_Limpieza/index.html#manipulación-de-carácteres",
    "href": "posts/SICOP_Limpieza/index.html#manipulación-de-carácteres",
    "title": "Limpieza de datos scrapeados con R",
    "section": "Manipulación de carácteres",
    "text": "Manipulación de carácteres"
  },
  {
    "objectID": "posts/SICOP_Limpieza/index.html#manipulación-de-carácteres-y-normalización",
    "href": "posts/SICOP_Limpieza/index.html#manipulación-de-carácteres-y-normalización",
    "title": "Limpieza de datos scrapeados con R",
    "section": "Manipulación de carácteres y normalización",
    "text": "Manipulación de carácteres y normalización\nDadas que las personas pueden escribir las mismas cosas de formas diferentes, los datos de tipo carácter/character se pueden volver complicados de procesar. Esto también incluye la posibilidad de espacios en blanco innecesarios (al inicio, entre o al final de las palabras). Este proceso se realiza en\n\n#| echo: false\n\n# Se renombra el encargado de publicación de gestión de objerciones y apertura\n# por un nombre corto\ncolnames(data_filtrado)[9] &lt;- \"Enc.Pub.Gest.Apertu\" \n\n# Se renombra el encargado de solicitar estudio de ofertas recomendación del acto final\n# por un nombre corto\n\ncolnames(data_filtrado)[11] &lt;- \"Enc.Solic.Est.Ofert\" \n\n\n# Se remueve texto innecesario (se identificó observando el set de datos)\ndata_filtrado$Nombre.de.la.institución &lt;- str_remove(data_filtrado$Nombre.de.la.institución, \"(?i)Cantón de\")\n\n# Se sustituyen los \"del\" por \"de\" para facilitar la creación del regex\ndata_filtrado$Nombre.de.la.institución &lt;- str_replace_all(data_filtrado$Nombre.de.la.institución,\"del\",\"de\")\n\n# Se separa en dos columna\ndata_filtrado &lt;- data_filtrado %&gt;% separate(Nombre.de.la.institución,\n                                            c(\"Institución\",\"Nombre\")\n                                            ,sep = \"(?i)\\\\A^.*?(?&lt;!de).*?\\\\Kde\")\n# Se limpian los espacios en blanco\ndata_filtrado$Nombre &lt;- str_trim(data_filtrado$Nombre,side = \"both\") \n\n# Se aplica limpieza sobre esas columnas\n# Se pasa a formato de titulo y se corrigen ciertos elementos\nfor (i in 10:12) {\ndata_filtrado[,i] &lt;- str_to_title(data_filtrado[,i])\ndata_filtrado[,i] &lt;- str_replace_all(data_filtrado[,i],'\\\\b(De)\\\\b',\"de\")\ndata_filtrado[,i] &lt;- str_replace_all(data_filtrado[,i],'\\\\b(Los)\\\\b',\"los\")\n}\n\n# Se pasa a formato de título y se pasa a minúscula el \"De\" resultante\ndata_filtrado$Institución &lt;- str_to_title(data_filtrado$Institución)\ndata_filtrado$Nombre &lt;- str_to_title(data_filtrado$Nombre)\ndata_filtrado$Nombre &lt;- str_replace_all(data_filtrado$Nombre,'\\\\b(De)\\\\b',\"de\")\n\n# data_filtrado &lt;- respaldo\nrespaldo &lt;- data_filtrado\n\n# Se pasa a formato de oración diversas columnas\nfor (i in 17:19) {\ndata_filtrado[,i] &lt;- str_to_sentence(data_filtrado[,i])\n}\ndata_filtrado$Enc.Solic.Est.Ofert &lt;- str_to_sentence(data_filtrado$Enc.Solic.Est.Ofert)\n\n# \ndata_filtrado$Nombre &lt;- str_replace_all(data_filtrado$Nombre,\" de Heredia\",\"\")\ndata_filtrado$Nombre &lt;- str_replace_all(data_filtrado$Nombre,\" de Pacayas\",\"\")"
  },
  {
    "objectID": "posts/SICOP_Limpieza/index.html#conversiones-de-tipos",
    "href": "posts/SICOP_Limpieza/index.html#conversiones-de-tipos",
    "title": "Limpieza de datos scrapeados con R",
    "section": "Conversiones de tipos",
    "text": "Conversiones de tipos\nPara la búsqueda y localización de errores es posible revisar las columnas de interés. Esto con tal de buscar y localizar posibles errores que afecten la consistencia de los datos. Antes de ello, es posible descartar algunas columnas que no ofrecen ningún tipo de información."
  },
  {
    "objectID": "posts/SICOP_Representacion/index.html",
    "href": "posts/SICOP_Representacion/index.html",
    "title": "Representación de datos",
    "section": "",
    "text": "library(tidyverse)\nlibrary(shiny)\nlibrary(ggpubr)\nlibrary(stringdist)\nlibrary(sf)\noptions(scipen=999)\nsetwd(\"~/GitHub/R-Geografia-y-Data/posts/SICOP_Representacion\")\ndata.sicop &lt;- read.csv(\"output/csv/TablaLimpiaSICOP.csv\")\ncant.sp &lt;- read_sf(\"sp/LimiteCantonal5K_.shp\")#, options = \"ENCODING=WINDOWS-1252\")\n\ndata.sicop$fecha.hora.publicacion &lt;- as.Date(data.sicop$Fecha.hora.de.publicación, \n                                             \"%d/%m/%Y %H:%M\")\n\ndata.sicop$Estado.del.concurso &lt;- sub(\"^$\", \"Sin clasificar\", \n                                      data.sicop$Estado.del.concurso)"
  },
  {
    "objectID": "posts/SICOP_Representacion/index.html#representación-general",
    "href": "posts/SICOP_Representacion/index.html#representación-general",
    "title": "Representación de datos",
    "section": "Representación general",
    "text": "Representación general\nCon los datos obtenidos es posible aplicar diferentes formas de representación. Algunas de las formas mas simples de representación son: diagramas de barras. En este caso se utiliza para conocer la frecuencia de elementos en una variable. En este caso se aplica con las variables:\n\nEstado del concurso\nTipo de Procedimiento\nTipo de modalidad\nClasificación del objeto\n\n\n# EL COUNT DE PLYR PARA para cambiar los valores vacios por \"Sin clasificar\"\ndata.filter &lt;- plyr::count(data.sicop$Estado.del.concurso) \n\n# Es posible explorar algunos atributos de interés\n# Se aplica el mismo procedimiento para las variables mencionadas\nconcurso &lt;- plyr::count(data.sicop$Estado.del.concurso) %&gt;% ggplot(aes(x = reorder(\n  x,-freq),y = freq)) +\n  geom_bar(stat = \"identity\",fill = \"#f68060\", alpha = 0.6, width = 0.4)+\n  coord_flip()+\n  scale_x_discrete(labels = label_wrap_gen(20)) +\n  xlab(\"\")+\n  ylab(\"\") +\n  ggtitle(\"Estado del concurso\") +\n  theme_bw()\n\nPara Estado del concurso y Tipo de procedimiento se obtiene:\n\n\n\n\n\nPara Tipo de modalidad y Clasificación del objeto se obtiene:\n\n\n\n\n\nTambién es posible explorar la frecuencia de los presupuestos totales estimado mediante un histograma. Al graficar se obtiene el siguiente resultado:\n\nggplot(data.sicop, aes(x=Presupuesto.total.estimado)) + \n  geom_histogram(bins = 40)\n\n\n\n\nAl existir una gran concentración de datos en bajos presupuestos y algunos dispersos en altos presupuestos el histograma no ofrece mucho detalle. Para obtener más detalle es posible filtrar por los valores que estén por abajo y por arriba de la media.\n\n# hist\n\n# POR ABAJO DE LA MEDIA\nabajo &lt;- data.sicop %&gt;% filter(Presupuesto.total.estimado &lt; \n                                 mean(Presupuesto.total.estimado)) %&gt;% \nggplot(aes(x=Presupuesto.total.estimado)) + \n  geom_histogram(bins = 80) +\n  ggtitle(\"Abajo de la media\")\n\n# POR ARRIBA DE LA MEDIA\narriba &lt;- data.sicop %&gt;% filter(Presupuesto.total.estimado &gt; \n                                  mean(Presupuesto.total.estimado)) %&gt;% \nggplot(aes(x=Presupuesto.total.estimado)) + \n  geom_histogram(bins = 80) +\n  ggtitle(\"Arriba de la media\")\n\n\nggarrange(abajo, arriba, \n          ncol = 1, nrow = 2)\n\n\n\n\nSe observa que la mayoría de valores se encuentra por debajo de la media. Para observar con más detalle, es posible filtrar aun más los datos. En este caso se filtra por los valores menores de 25 000 000 CRC (esto para apreciar la mayor concentración de datos).\n\ndata.sicop %&gt;% filter(Presupuesto.total.estimado &lt; 25000000) %&gt;% \nggplot(aes(x=Presupuesto.total.estimado)) + \n  geom_histogram(bins = 80) +\n  ggtitle(\"Por abajo de 25 millones de colones\")"
  },
  {
    "objectID": "posts/OSM_ScrapePuntos/index.html",
    "href": "posts/OSM_ScrapePuntos/index.html",
    "title": "Webscrape de puntos de Open Street Map (OSM)",
    "section": "",
    "text": "Obtención de datos de Open Street Map (OSM) mediante webscraping\nOpen Street Map (OSM) es una base de datos geográfica gratis que es actualizada y mantenida de forma colaborativa. Estos datos son capturados con dispositivos GPS, ortofotografías y otras fuentes libres. Se distribuyen bajo la Licencia Abierta de Bases de Datos (ODbL). Esta licencia permite a los usuarios usar, compartir y modificar libremente la base de datos de forma que se mantiene la misma libertad para los demás.\nEn la página web de Open Street Map es posible buscar la ubicación de Instituciones. En este caso interesa conocer la ubicación de cada Municipalidad en los ochenta y dos cantones del Costa Rica. Para lograr esto, se cuenta con la capa de cantones de Costa Rica la cual ofrece la lista de cantones del país.\nSe utilizará la librería RSelenium (Harrison, 2022) la cual permite manejar un navegador web de forma nativa o remota. Con esta librería es posible automatizar tareas en los navegadores. Para lograr obtener la ubicación de las municipalidades, es posible automatizar la tarea de buscar todas las municipalidades y sus respectivas coordenadas.\nEsto también es posible mediante la utilización de la API (Application Programming Interface) pero el soporte en lenguaje R no es muy flexible. Con la librería osmdata (Padgham et al., 2017) se pueden obtener datos de la siguiente forma:\n\nlibrary(osmdata) # \nlibrary(tidyverse) #\nlibrary(sf) #\nlibrary(kableExtra) #\n# Capa de cantones de Costa Rica, se usará como bounding box\ncant.sp &lt;- sf::read_sf(\"sp/LimiteCantonal5K_.shp\")\n\n# Se transforma a WGS84\nbbox_wgs84 &lt;- st_bbox(st_transform(cant.sp, crs = \"WGS84\"))\n\n# Se extraen los datos con los límites de la capa cant.sp\ndatos_muni &lt;- opq(bbox = bbox_wgs84) %&gt;% # \"Overpass\" query\n                add_osm_feature(key = \"amenity\",\n                        value = 'townhall',\n                        value_exact = F) %&gt;% \n                osmdata_sf()\n\n# Los datos extraídos poseen puntos, polígonos y multipolígonos.\n# en nuestro caso interesan los puntos\npuntos &lt;- datos_muni$osm_points\n\n# Se transforma a UTF-8 ya que posee otra codificación\npuntos &lt;- dplyr::mutate_if(puntos, is.character, \n                           .funs = function(x){return(`Encoding&lt;-`(x, \"UTF-8\"))})\n\nAl revisar los datos, se aprecia que existen muchos valores sin nombre y que algunos de ellos no corresponden a municipalidades. Para observar los registros con nombre se eliminan los que no poseen nombre. Estos son algunos de los resultados:\n\n# Se remueven los valores en blanco\ntabla &lt;- dplyr::filter(puntos, grepl(\"\",name))\n\n\n\n\n\n\nosm_id\nname\naddr.city\naddr.street\n\n\n\n\nConcejo Municipal Distrito Paquera\nPaquera\nCalle Central\ntownhall\n\n\nConcejo Municipal Distrito Colorado\nColorado\nNA\ntownhall\n\n\nMunicipalidad de La Cruz\nLa Cruz\nNA\ntownhall\n\n\nConcejo Municipal Distrito Lepanto\nLepanto\nVía 21\ntownhall\n\n\nConcejo Municipal Distrito Cóbano\nCóbano\nNA\ntownhall\n\n\nConcejo Municipal Distrito Tucurrique\nTucurrique\nNA\ntownhall\n\n\n\n\n\n\n\nSe aprecia que los resultados no incluyen todas las municipalidades del país. Por su parte los datos de polígonos y multipolígonos si poseen información sobre las municipalidades pero el proceso para obtener una ubicación puntual asociada a cada municipalidad podría ser un poco tedioso. Ante esto, es posible plantear un webscrape con RSelenium en el que se busque cada Municipalidad del país en la página web de OSM y en caso que exista más de un resultado, se utilizaría el más similar a lo deseado. Para evaluar la similitud de un string con otro, se utiliza la librería stringdist (Loo, 2014) el cual ofrece un puntaje de similitud entre dos strings.\nDespués de realizar una búsqueda se aprecia que la localización puntual del elemento es incluída en la estructura de la página, lo cual se puede usar para extraer las coordenadas.\n\n\n\nFigura 1: HTML de la página web\n\n\nEn un resultado de búsqueda, las municipalidades pueden ser denominadas “Palacio Municipal” por lo que si no se encuentra similitud con “Municipalidad de (Cantón)” se intenta con Palacio Municipal.\n\n\nPlanteamiento del webscrape con RSelenium\n\nlibrary(stringdist) # Comparar similitud de strings\nlibrary(RSelenium) # RSelenium\nlibrary(tidyverse) # \nlibrary(seleniumPipes) # Implementa W3C webdriver\nlibrary(netstat) # Para el free_port()\n# Empezar el servidor\nrs_driver_object &lt;- rsDriver(browser = 'chrome', # Se utilizará Google Chrome\n                             chromever = 'latest', # Versión de Chrome\n                             verbose = FALSE, # No incluir mensajes de estado\n                             port = free_port(), # Se utiliza un puerto libre\n                             check = TRUE) # Checar si hay nuevas versiones\n\n# crear un objeto cliente\nremDr &lt;- rs_driver_object$client\n\n# Se navega a la página de interés\n\nremDr$navigate('https://www.openstreetmap.org') # \n\nPara poder automatizar la búsqueda de todas las municipalidades es necesario conocer como referirse al cuadro de búsqueda. Al revisar en la página, el xpath completo del cuadro de búsqueda es /html/body/div/div[1]/div[1]/form[1]/div/div[1]/div/input[1], con lo cual se puede interactuar con el mismo de la siguiente forma:\n\n# Se asigna el xpath a una variable para simplificar el código\nxpath_cuadro &lt;- \"/html/body/div/div[1]/div[1]/form[1]/div/div[1]/div/input[1]\"\n\n# Se busca en el web driver\ncuadro_busqueda &lt;- remDr$findElement(\"xpath\",xpath_cuadro)\n\n# Se envía texto al elemento pero debe ser en formato lista\ncuadro_busqueda$sendKeysToElement(list(paste0(\"Municipalidad de \",\n                                                cant.sp$canton[1], \" Costa Rica\")))\n\n# El texto se puede limpiar de la siguiente forma:\ncuadro_busqueda$clearElement()\n\nPara realizar la búsqueda se realiza un proceso similar (se identifica el xpath pero se da click en el elemento). También es posible escribir la indicación de click inmediatamente de la siguiente forma:\n\n# Se envía texto al elemento pero debe ser en formato lista\ncuadro_busqueda$sendKeysToElement(list(paste0(\"Municipalidad Heredia\")))\n\n# xpath para buscar el elemento\nclick_busqueda &lt;- '//*[@id=\"sidebar\"]/div[1]/form[1]/div/div[1]/div/input[2]'\n\n# Indicaciones para dar click\nremDr$findElement(\"xpath\",click_busqueda)$clickElement()\n\n\n\n\n\n\nCon esta búsqueda, se obtienen dos resultados (lo cual varía según el área de búsqueda) pero el resultado deseado es específicamente la “Municipalidad de Heredia”. Para identificar mediante código el resultado deseado, es posible comparar los resultados obtenidos con el resultado deseado.\n\n# xpath para identificar los resultados visibles\nresultados_busqueda &lt;- \"/html/body/div/div[1]/div[5]/div[2]/ul/li/a\"\n\n# Se utiliza \"findElements\" ya que se desean todos los elementos\ncl_result &lt;- remDr$findElements(\"xpath\",resultados_busqueda)\n\nSe obtiene una lista del tamaño de la cantidad de resultados visibles (podrían ser más si se presiona en More Results). Para acceder al nombre de la municipalidad, separarlo de la dirección y compararlo con lo deseado es posible realizar el siguiente procedimiento:\n\nnombres_resultado &lt;- data.frame(matrix(nrow = 0, ncol = 3))\ncolnames(nombres_resultado) &lt;- c(\"Nombre_completo\",\"Nombre\",\"Similitud\")\nfor (i in 1:length(cl_result)) {\n  # Se añade al dataframe\n  nombres_resultado[i,1] &lt;- as.character(cl_result[[i]]$getElementText())\n  \n  \n  # Se divide por la coma y se selecciona el primer resultado\n  nombres_resultado[i,2] &lt;- str_split(nombres_resultado[i,1],\",\")[[1]][1]\n\n  # Similitud\n  nombres_resultado[i,3] &lt;- stringsim(\"Municipalidad Heredia\",nombres_resultado[i,2])\n}\n\n\n\n\n\n\nX\nNombre_completo\nNombre\nSimilitud\n\n\n\n\n1\nMunicipalidad de Barva, Calle 2 Nicolás Aguilar, El Calvario, Barva, Cantón Barva, Heredia Province, 40201, Costa Rica\nMunicipalidad de Barva\n0.7272727\n\n\n2\nMunicipalidad de San Rafael, Calle 35, La Terraza, San Rafael, Cantón San Rafael, Heredia Province, 40501, Costa Rica\nMunicipalidad de San Rafael\n0.5925926\n\n\n3\nMunicipalidad de Heredia, Avenida Central Paseo de la Cultura, Oriente, Corazón de Jesús, Heredia, Cantón Heredia, Heredia Province, 40101, Costa Rica\nMunicipalidad de Heredia\n0.8750000\n\n\n4\nMunicipalidad de San Isidro, Calle Central, Cristo Rey, San Isidro, Cantón San Isidro, Heredia Province, 40601, Costa Rica\nMunicipalidad de San Isidro\n0.5925926\n\n\n5\nMunicipalidad de Belén, Calle 152, San Vicente, San Antonio, Cantón Belén, Heredia Province, 40701, Costa Rica\nMunicipalidad de Belén\n0.7272727\n\n\n6\nMunicipalidad de Santo Domingo, Calle Central, Santo Domingo, Cantón San Pablo, Heredia Province, 40901, Costa Rica\nMunicipalidad de Santo Domingo\n0.5333333\n\n\n\n\n\n\n\nSe aprecia que el tercer resultado es el que posee mayor similitud con el string deseado, por tanto la información se extraería del mismo. Ya que se identificó el resultado deseado, es posible explorar como obtener las coordenadas del mismo. Para esto al revisar Figura 1 se aprecia que existe un atributo asociado a las coordenadas del elemento de búsqueda asociado. Para extraer las coordenadas, se puede realizar el siguiente procedimiento:\n\n# Para saber cual es el de mayor similitud\nres_similar &lt;- as.numeric(which(tolower(nombres_resultado$Similitud) &gt; 0.85))\n\n\n# Se encuentra la coordenada y se muestra\nlon &lt;- cl_result[[res_similar]]$getElementAttribute(\"data-lon\")[[1]]\n  \n# Se encuentra la coordenada y se muestra\nlat &lt;- cl_result[[res_similar]]$getElementAttribute(\"data-lat\")[[1]]\n\nprint(paste(\"La longitud de la Municipalidad de Heredia es\",lon))\nprint(paste(\"La latitud de la Municipalidad de Heredia es\",lat))\n\n\n\n[1] \"La longitud de la Municipalidad de Heredia es -84.1162254\"\n\n\n[1] \"La latitud de la Municipalidad de Heredia es 9.9989845\"\n\n\nCon esto es posible iterar por todos los nombres de cantón y guardar las coordenadas para cada municipalidad. Se plantea de la siguiente manera:\n\n# Nombre de columna para la tabla de salida\nncol_municipalidades &lt;- c(\"Canton\",\"Nombre\",\"Tipo\",\"X\",\"Y\")\n\n# Dataframe con cantidad de nombre de columna igual a ncol_municipalidades\ndf &lt;- data.frame(matrix(nrow = 0, ncol = length(ncol_municipalidades)))\n\n# Se asignan los nombres de columna\ncolnames(df) &lt;- ncol_municipalidades\n\n# Se asignan xpath para evitar ruido en el código\ncuadro_busqueda &lt;- '/html/body/div/div[1]/div[1]/form[1]/div/div[1]/div/input[1]'\nclick_busqueda &lt;- '//*[@id=\"sidebar\"]/div[1]/form[1]/div/div[1]/div/input[2]'\nresultados_busqueda &lt;- \"/html/body/div/div[1]/div[5]/div[2]/ul/li/a\"\n\n# La iteración va de 1 al número de cantones (82)\nfor (i in 1:length(cant.sp$canton)) {\n  \n  rm(r)\n  # Limpiar el cuadro de búsqueea\n  remDr$findElement(\"xpath\",cuadro_busqueda)$clearElement()\n  \n  # Se selecciona el cuadro de busqueda\n  busqueda &lt;- remDr$findElement(\"xpath\",cuadro_busqueda)\n  \n  # Se envía el texto al cuadro de texto\n  busqueda$sendKeysToElement(list(paste0(\"Municipalidad de \", \n                                                cant.sp$canton[i], \" Costa Rica\")))\n  \n  # Se da click al botón de buscar\n  remDr$findElement(\"xpath\",click_busqueda)$clickElement()\n  \n  Sys.sleep(3)\n\n  ## Se revisa si el texto de \"Resultados\" está presente \n  ## Lo cual es indicador de que hubo más de un resultado\n  try(assign(\"r\",length(remDr$findElements(\"xpath\",resultados_busqueda))),silent = T)\n  \n  # Si \"r\" es igual a 0 se borra (ya que no hubieron mas resultados)\n  Sys.sleep(5)\n  # el string deseado\n  if(r &lt; 2L){\n    rm(r)\n    resultado_similar &lt;- 1\n    cl_result &lt;- remDr$findElements(\"xpath\",resultados_busqueda)\n    }\n  if (exists(\"r\") == TRUE) {\n    # Cantidad de resultados\n    a &lt;- as.numeric(r)\n    \n    # Variable para clickear\n    cl_result &lt;- remDr$findElements(\"xpath\",resultados_busqueda)\n    \n    # Se crea una tabla\n    lista_resultados &lt;- data.frame(matrix(nrow = 0, ncol = 4))\n    colnames(lista_resultados) &lt;- c(\"Resultado_Completo\",\"Tipo\",\"Resultado_Split\",\"Score\")\n    for (it_result in 1:r) {\n\n      # Se itera sobre la tabla creada para añadirle los resultados\n      lista_resultados[it_result,1] &lt;- unlist(cl_result[[it_result]]$getElementText())\n      lista_resultados[it_result,2] &lt;- cl_result[[it_result]]$getElementAttribute(\"data-prefix\")[[1]]\n      lista_resultados[it_result,3] &lt;- str_split(lista_resultados[it_result,1],\",\")[[1]][1]\n      # Este string puede mejorar\n      lista_resultados[it_result,4] &lt;- stringsim(paste0(\"Municipalidad \",cant.sp$canton[i]),\n                                          lista_resultados[it_result,3])\n    }\n    # Si el puntaje de similitud es mayor a 0.85 se procede\n    if (max(lista_resultados$Score) &gt; 0.85) {\n    # Se busca la palabra similar\n    resultado_similar &lt;- as.numeric(which(tolower(lista_resultados$Score) &gt; 0.85 &\n                                            lista_resultados$Tipo == \"Town Hall\"))[[1]]\n    }\n    # Si el puntaje de similitud es menor a 0.85 se procede\n    if (max(lista_resultados$Score) &lt; 0.85) {\n    # Se busca el resultado Palacio Municipal\n    resultado_similar &lt;- which(grepl(\"palacio municipal\",\n                                    tolower(lista_resultados$Resultado)) == TRUE)\n    }\n  }\n  # Se añade el nombre del cantón\n  df[i,1] &lt;- cant.sp$canton[i]\n  \n  # Dirección\n  df[i,2] &lt;- unlist(cl_result[[resultado_similar]]$getElementText())\n  \n  # Tipo\n  df[i,3] &lt;- cl_result[[resultado_similar]]$getElementAttribute(\"data-prefix\")[[1]]\n  \n  # Se añade la coordenada\n  df[i,4] &lt;- cl_result[[resultado_similar]]$getElementAttribute(\"data-lon\")[[1]]\n  \n  # Se añade la coordenada\n  df[i,5] &lt;- cl_result[[resultado_similar]]$getElementAttribute(\"data-lat\")[[1]]\n  \n  print(paste0(\"Iteración \",i,\" Municipalidad del cantón de \", cant.sp$canton[i]))\n}\n\nwrite.csv(df,\"output/csv/Puntos_Municipalidades.csv\")\n\n\n\nVisualización de puntos obtenidos\nLos resultados obtenido pueden ser plasmados en un mapa para comprobar las ubicaciones. Esto se puede realizar con la librería leaflet (Cheng et al., 2021). Se configura de forma que al dar click en cada punto es posible ver la dirección asociada al mismo (aunque se puede mostrar otra información pero en este caso se mostrará la dirección).\n\nlibrary(leaflet)\nleaflet() %&gt;% addTiles() %&gt;% \n  addCircleMarkers(lng = as.numeric(df$X),\n                   lat = as.numeric(df$Y), popup = df$Nombre)\n\n\n\n\n\n\n\n\n\n\nReferencias\n\nCheng, J., Karambelkar, B., & Xie, Y. (2021). leaflet: Create Interactive Web Maps with the JavaScript ’Leaflet’ Library. https://CRAN.R-project.org/package=leaflet\n\n\nHarrison, J. (2022). RSelenium: R Bindings for ’Selenium WebDriver’. https://CRAN.R-project.org/package=RSelenium\n\n\nLoo, M. P. J. van der. (2014). The stringdist package for approximate string matching. 6, 111-122. https://CRAN.R-project.org/package=stringdist\n\n\nPadgham, M., Rudis, Bob., Lovelace, R., & Salmon, M. (2017). osmdata. 2, 305. https://doi.org/10.21105/joss.00305"
  },
  {
    "objectID": "posts/SICOP_Representacion/index.html#representación-espacial-de-datos",
    "href": "posts/SICOP_Representacion/index.html#representación-espacial-de-datos",
    "title": "Representación de datos",
    "section": "Representación espacial de datos",
    "text": "Representación espacial de datos\nCada elemento que fue scrapeado en las etapas anteriores está asociado a una municipalidad, las cuales pueden asociarse a su ubicación puntual (coordenadas de ubicación de la municipalidad) o a toda la unidad espacial (cantón). En otra entrada de foro se obtuvieron las ubicaciones puntuales de las municipalidades del país. Dichos puntos pueden ser asociados a la información obtenida del SICOP para realizar una representación espacial. Para simplificar, sería posible agregar las coordenadas a la capa de cantones; también se añaden los datos de conteo de categorías para las variables Estado del concurso, Tipo de procedimiento y Tipo de modalidad.\n\n# Se leen los puntos de las municipalidades\npuntos_muni &lt;- read.csv(\"csv/Puntos_Municipalidades.csv\")\ndata.sicop.graficos &lt;- read.csv(\"csv/Tab_Cod_SICOP.csv\")\n\n# Se añade formato\ncolnames(data.sicop.graficos) &lt;- str_replace_all(colnames(data.sicop.graficos),pattern = \"\\\\.\",replacement = \" \")\ncolnames(data.sicop.graficos)[2] &lt;- \"canton.sint\"\n\n# Se crea una columna con cantones sin tilde (facilita join despues)\n# Se utiliza un array de caracteres no deseados\nunwanted_array &lt;- list('Š'='S', 'š'='s', 'Ž'='Z', 'ž'='z','À'='A', 'Á'='A', 'Â'='A','Ã'='A', 'Ä'='A', 'Å'='A', 'Æ'='A', 'Ç'='C', 'È'='E', 'É'='E','Ê'='E', 'Ë'='E', 'Ì'='I', 'Í'='I', 'Î'='I', 'Ï'='I', 'Ò'='O', 'Ó'='O', 'Ô'='O', 'Õ'='O', 'Ö'='O', 'Ø'='O', 'Ù'='U','Ú'='U', 'Û'='U', 'Ü'='U', 'Ý'='Y', 'Þ'='B', 'ß'='Ss', 'à'='a', 'á'='a', 'â'='a', 'ã'='a','ä'='a','å'='a', 'æ'='a', 'ç'='c','è'='e', 'é'='e', 'ê'='e', 'ë'='e','ì'='i','í'='i', 'î'='i', 'ï'='i', 'ð'='o', 'ò'='o', 'ó'='o', 'ô'='o', 'õ'='o','ö'='o', 'ø'='o', 'ù'='u', 'ú'='u', 'û'='u', 'ý'='y', 'ý'='y', 'þ'='b', 'ÿ'='y' ) \n\n# Se aplica lo siguiente para crear una columna de cantones sin tilde\ncant.sp$canton.sint &lt;- gsubfn::gsubfn(paste(names(unwanted_array),\n                                            collapse='|'),\n                                            unwanted_array,\n                                            as.character(cant.sp$canton))\n  \ncant.sp &lt;- left_join(cant.sp,data.sicop.graficos, by = \"canton.sint\")\n\n\ncant.sp$sum.procedimiento &lt;- cant.sp$`Licitación abreviada` + cant.sp$`Licitación menor` + cant.sp$`Licitación pública nacional` + cant.sp$`Licitación reducida` + cant.sp$`Contratación especial` + cant.sp$`Contratación directa` + cant.sp$Remate\n\n# Añadir coordenadas a la capa de cantones\ncant.sp$X &lt;- puntos_muni$X\ncant.sp$Y &lt;- puntos_muni$Y\n\n# Se agrupa por nombres (cantones) y se hace un resumen por suma del presupuesto\n# y se convierte a data frame\ndata.sicop.presup &lt;- data.sicop %&gt;% group_by(Nombre) %&gt;% \n  summarise(presup.tot.est=sum(Presupuesto.total.estimado),\n            .groups = 'drop') %&gt;%\n  as.data.frame()\n\n# Se cambia el nombre de columna para facilitar el join\ncolnames(data.sicop.presup) &lt;- c(\"canton\",\"presup.tot.est\")\n\n# Se hace el join por la columna \"canton\"\ncant.sp &lt;- left_join(cant.sp,data.sicop.presup, by = \"canton\")\n\nCon los datos actuales es posible plasmarlos con la librería leaflet. Se utiliza radius para aumentar el tamaño de los puntos según el presupuesto. También se añade un popup (al dar click a cada punto) que muestre la provincia, cantón y el presupuesto.\n\nlibrary(leaflet)\nlibrary(scales)\n\nleaflet() %&gt;% addTiles() %&gt;% \n  addCircleMarkers(lng = as.numeric(cant.sp$X),\n                   lat = as.numeric(cant.sp$Y),\n                  radius = rescale(cant.sp$presup.tot.est, to = c(5,40)),\n                   popup = paste0(\"&lt;strong&gt;Provincia: &lt;/strong&gt;\",cant.sp$provincia, \n                                  \"&lt;br&gt;&lt;strong&gt;\",\"Cantón: &lt;/strong&gt;\",cant.sp$canton,\n                                  \"&lt;br&gt;&lt;strong&gt;\",\"Presupuesto total: &lt;/strong&gt;₡\",\n                                  formatC(cant.sp$presup.tot.est,\n                                  format=\"fg\", big.mark=',')))"
  }
]