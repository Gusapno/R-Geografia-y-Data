add_osm_feature(key = "amenity", value = 'townhall',
value_exact = F) %>%
# Se convierte a formato "sf"
osmdata_sf()
# Los datos extraídos poseen puntos, polígonos y multipolígonos.
# en nuestro caso interesan los puntos
puntos <- muni$osm_points
# Los datos extraídos poseen puntos, polígonos y multipolígonos.
# en nuestro caso interesan los puntos
puntos <- datos_muni$osm_points
# Se transforma a UTF-8 ya que posee otra codificación
puntos <- dplyr::mutate_if(puntos, is.character,
.funs = function(x){return(`Encoding<-`(x, "UTF-8"))})
View(puntos)
# Se extraen los datos con los límites de la capa cant.sp
datos_muni <- opq(bbox = bbox_wgs84) %>%
add_osm_feature(key = "amenity", value = 'townhall',
value_exact = F) %>%
osmdata_sf()
# Los datos extraídos poseen puntos, polígonos y multipolígonos.
# en nuestro caso interesan los puntos
puntos <- datos_muni$osm_points
bbox_wgs84 <- st_bbox(st_transform(cant.sp, crs = "WGS84"))
muni <- opq(bbox = bbox_wgs84) %>%
add_osm_feature(key = "amenity", value = 'townhall',
value_exact = F) %>%
osmdata_sf()
puntos <- muni$osm_polygons
View(puntos)
# Los datos extraídos poseen puntos, polígonos y multipolígonos.
# en nuestro caso interesan los puntos
puntos <- datos_muni$osm_points
View(puntos)
# Los datos extraídos poseen puntos, polígonos y multipolígonos.
# en nuestro caso interesan los puntos
puntos <- datos_muni$osm_points
# Se transforma a UTF-8 ya que posee otra codificación
puntos <- dplyr::mutate_if(puntos, is.character,
.funs = function(x){return(`Encoding<-`(x, "UTF-8"))})
test <- dplyr::filter(puntos, !grepl("Municipalidad",puntos))
test <- dplyr::filter(puntos, !grepl("Municipalidad",name))
View(test)
test <- dplyr::filter(puntos, grepl("Municipalidad",name))
View(test)
grepl("Municipalidad",puntos$name)
test <- dplyr::filter(puntos, grepl("Municipalidad de",name))
View(test)
View(puntos)
test <- dplyr::filter(puntos, grepl(!NA,name))
View(test)
# Se transforma a UTF-8 ya que posee otra codificación
puntos <- dplyr::mutate_if(puntos, is.character,
.funs = function(x){return(`Encoding<-`(x, "UTF-8"))})
test <- dplyr::filter(puntos, grepl(!NA,name))
test <- dplyr::filter(puntos, grepl(NA,name))
test <- dplyr::filter(puntos, grepl(NA,name))
test <- dplyr::filter(puntos, grepl("",name))
View(test)
View(test)
library(kableExtra) #
kable(test)
kable(test[,3:length(test)], format = "html", table.attr = "style='width:30%;'") %>%
kableExtra::kable_styling()
kable(test[,4:length(test)], format = "html", table.attr = "style='width:30%;'") %>%
kableExtra::kable_styling()
length(test)
kable(test[4:length(test),], format = "html", table.attr = "style='width:30%;'") %>%
kableExtra::kable_styling()
kable(test[,2:5], format = "html", table.attr = "style='width:30%;'") %>%
kableExtra::kable_styling()
test[,3:5]
test[,4:5]
kable(test[,2:5], format = "html", table.attr = "style='width:30%;'",row.names = FALSE) %>%
kableExtra::kable_styling()
kable(head(test[,2:5]), format = "html", table.attr = "style='width:30%;'",row.names = FALSE) %>%
kableExtra::kable_styling()
View(muni)
View(muni[["osm_multipolygons"]])
View(muni[["osm_polygons"]])
# Los datos extraídos poseen puntos, polígonos y multipolígonos.
# en nuestro caso interesan los puntos
puntos <- datos_muni$osm_polygons
# Los datos extraídos poseen puntos, polígonos y multipolígonos.
# en nuestro caso interesan los puntos
puntos <- datos_muni$osm_polygons
# Se transforma a UTF-8 ya que posee otra codificación
puntos <- dplyr::mutate_if(puntos, is.character,
.funs = function(x){return(`Encoding<-`(x, "UTF-8"))})
#| warning: false
#| eval: false
library(stringdist) # Comparar similitud de strings
library(RSelenium) # RSelenium
library(tidyverse) #
library(seleniumPipes) # Implementa W3C webdriver
library(netstat) # Para el free_port()
# Empezar el servidor
rs_driver_object <- rsDriver(browser = 'chrome', # Se utilizará Google Chrome
chromever = 'latest', # Versión de Chrome
verbose = FALSE, # No incluir mensajes de estado
port = free_port(), # Se utiliza un puerto libre
check = TRUE) # Checar si hay nuevas versiones
# crear un objeto cliente
remDr <- rs_driver_object$client
# Se navega a la página de interés
remDr$navigate('https://www.openstreetmap.org') #
error="Error : \t Summary: NoSuchElement\n \t Detail: An element could not be located on the page using the given search parameters.\n \t class: org.openqa.selenium.NoSuchElementException\n\t Further Details: run errorDetails method\n"
#| warning: false
#| eval: false
# Nombre de columna para la tabla de salida
ncol_municipalidades <- c("Canton","Nombre","X","Y")
# Dataframe con cantidad de nombre de columna igual a ncol_municipalidades
df <- data.frame(matrix(nrow = 0, ncol = length(ncol_municipalidades)))
# Se asignan los nombres de columna
colnames(df) <- ncol_municipalidades
# Se asignan xpath para evitar ruido en el código
cuadro_busqueda <- '/html/body/div/div[1]/div[1]/form[1]/div/div[1]/div/input[1]'
click_busqueda <- '//*[@id="sidebar"]/div[1]/form[1]/div/div[1]/div/input[2]'
resultados_busqueda <- "/html/body/div/div[1]/div[5]/div[2]/ul/li/a"
for (i in 1:length(cant.sp$canton)) {
rm(r)
# Limpiar el cuadro de búsqueea
remDr$findElement("xpath",cuadro_busqueda)$clearElement()
# Se selecciona el cuadro de busqueda
busqueda <- remDr$findElement("xpath",cuadro_busqueda)
# Se envía el texto al cuadro de texto
busqueda$sendKeysToElement(list(paste0("Municipalidad de ",
cant.sp$canton[i], " Costa Rica")))
# Se da click al botón de buscar
remDr$findElement("xpath",click_busqueda)$clickElement()
Sys.sleep(1)
# Si hay más de un resultado se debe seleccionar el más similar a la búsqueda
## Se revisa si el texto de "Resultados" está presente
## Lo cual es indicador de que hubo más de un resultado
#r <- unlist(
try(assign("r",length(remDr$findElements("xpath",resultados_busqueda))),silent = T)
# Si "r" es igual a 0 se borra (ya que no hubieron mas resultados)
Sys.sleep(2)
# el string deseado
if(r < 2L){
rm(r)
resultado_similar <- 1
cl_result <- remDr$findElements("xpath",resultados_busqueda)
}
if (exists("r") == TRUE) {
# Cantidad de resultados
a <- as.numeric(r)
# Variable para clickear
cl_result <- remDr$findElements("xpath",resultados_busqueda)
# Se crea una tabla z
lista_resultados <- data.frame(matrix(nrow = 0, ncol = 3))
colnames(lista_resultados) <- c("Resultado_Completo","Resultado_Split","Score")
for (it_result in 1:r) {
# Se itera sobre la tabla creada para añadirle los resultados
lista_resultados[it_result,1] <- unlist(cl_result[[it_result]]$getElementText())
lista_resultados[it_result,2] <- str_split(lista_resultados[it_result,1],",")[[1]][1]
# Este string puede mejorar
lista_resultados[it_result,3] <- stringsim(paste0("Municipalidad ",cant.sp$canton[i]),
lista_resultados[it_result,2])
}
# Si el puntaje de similitud es mayor a 0.85 se procede
if (max(lista_resultados$Score) > 0.85) {
# Se busca la palabra similar
resultado_similar <- as.numeric(which(tolower(lista_resultados$Score) > 0.85))
# Se clickea dicho resultado
#click_result[[resultado_similar[1]]]$clickElement()
}
# Si el puntaje de similitud es menor a 0.85 se procede
if (max(lista_resultados$Score) < 0.85) {
# Se busca el resultado Palacio Municipal
resultado_similar <- which(grepl("palacio municipal",
tolower(lista_resultados$Resultado)) == TRUE)
# Se clickea el que sea igual a "Palacio municipal"
#click_result[[palacio_busqueda]]$clickElement()
}
}
# Espera para que la pagina cargue
#Sys.sleep(1)
# Se añade el nombre del cantón
df[i,1] <- cant.sp$canton[i]
df[i,2] <- unlist(cl_result[[resultado_similar]]$getElementText())
# Se añade la coordenada
df[i,3] <- cl_result[[resultado_similar]]$getElementAttribute("data-lon")[[1]]
# Se añade la coordenada
df[i,4] <- cl_result[[resultado_similar]]$getElementAttribute("data-lat")[[1]]
print(paste0("Iteración ",i," Municipalidad del cantón de ", cant.sp$canton[i]))
# Se añade el nombre del elemento
}
cl_result[[resultado_similar]]
cl_result <- remDr$findElements("xpath",resultados_busqueda)
#| warning: false
#| eval: true
library(osmdata) #
library(tidyverse) #
library(sf) #
library(kableExtra) #
# Cantones
cant.sp <- sf::read_sf("sp/LimiteCantonal5K_.shp")
# Se transforma a WGS84
bbox_wgs84 <- st_bbox(st_transform(cant.sp, crs = "WGS84"))
# Se extraen los datos con los límites de la capa cant.sp
datos_muni <- opq(bbox = bbox_wgs84) %>%
add_osm_feature(key = "amenity",
value = 'townhall',
value_exact = F) %>%
osmdata_sf()
#| warning: false
#| eval: false
library(stringdist) # Comparar similitud de strings
library(RSelenium) # RSelenium
library(tidyverse) #
library(seleniumPipes) # Implementa W3C webdriver
library(netstat) # Para el free_port()
# Empezar el servidor
rs_driver_object <- rsDriver(browser = 'chrome', # Se utilizará Google Chrome
chromever = 'latest', # Versión de Chrome
verbose = FALSE, # No incluir mensajes de estado
port = free_port(), # Se utiliza un puerto libre
check = TRUE) # Checar si hay nuevas versiones
# crear un objeto cliente
remDr <- rs_driver_object$client
# Se navega a la página de interés
remDr$navigate('https://www.openstreetmap.org') #
xpath_cuadro <- "/html/body/div/div[1]/div[1]/form[1]/div/div[1]/div/input[1]"
cuadro_busqueda <- remDr$findElement("xpath",xpath_cuadro)
# Se envía texto al elemento pero debe ser en formato lista
cuadro_busqueda$sendKeysToElement(list(paste0("Municipalidad de ",
cant.sp$canton[i], " Costa Rica")))
# Se envía texto al elemento pero debe ser en formato lista
cuadro_busqueda$sendKeysToElement(list(paste0("Municipalidad de ",
cant.sp$canton[1], " Costa Rica")))
cuadro_busqueda$clearElement()
#| warning: false
#| eval: false
library(stringdist) # Comparar similitud de strings
library(RSelenium) # RSelenium
library(tidyverse) #
library(seleniumPipes) # Implementa W3C webdriver
library(netstat) # Para el free_port()
# Empezar el servidor
rs_driver_object <- rsDriver(browser = 'chrome', # Se utilizará Google Chrome
chromever = 'latest', # Versión de Chrome
verbose = FALSE, # No incluir mensajes de estado
port = free_port(), # Se utiliza un puerto libre
check = TRUE) # Checar si hay nuevas versiones
# crear un objeto cliente
remDr <- rs_driver_object$client
# Se navega a la página de interés
remDr$navigate('https://www.openstreetmap.org') #
# Se asigna el xpath a una variable para simplificar el código
xpath_cuadro <- "/html/body/div/div[1]/div[1]/form[1]/div/div[1]/div/input[1]"
# Se busca en el web driver
cuadro_busqueda <- remDr$findElement("xpath",xpath_cuadro)
# Se envía texto al elemento pero debe ser en formato lista
cuadro_busqueda$sendKeysToElement(list(paste0("Municipalidad de ",
cant.sp$canton[1], " Costa Rica")))
# El texto se puede limpiar de la siguiente forma:
cuadro_busqueda$clearElement()
# Se envía texto al elemento pero debe ser en formato lista
cuadro_busqueda$sendKeysToElement(list(paste0("Municipalidad de ",
cant.sp$canton[1], " Costa Rica")))
click_busqueda <- '//*[@id="sidebar"]/div[1]/form[1]/div/div[1]/div/input[2]'
remDr$findElement("xpath",click_busqueda)$clickElement()
# Se envía texto al elemento pero debe ser en formato lista
cuadro_busqueda$sendKeysToElement(list(paste0("Municipalidad Quepos")))
# El texto se puede limpiar de la siguiente forma:
cuadro_busqueda$clearElement()
# Se envía texto al elemento pero debe ser en formato lista
cuadro_busqueda$sendKeysToElement(list(paste0("Municipalidad Quepos")))
click_busqueda <- '//*[@id="sidebar"]/div[1]/form[1]/div/div[1]/div/input[2]'
remDr$findElement("xpath",click_busqueda)$clickElement()
# Se envía texto al elemento pero debe ser en formato lista
cuadro_busqueda$sendKeysToElement(list(paste0("Municipalidad Heredia")))
# El texto se puede limpiar de la siguiente forma:
cuadro_busqueda$clearElement()
# Se envía texto al elemento pero debe ser en formato lista
cuadro_busqueda$sendKeysToElement(list(paste0("Municipalidad Heredia")))
remDr$findElement("xpath",click_busqueda)$clickElement()
# El texto se puede limpiar de la siguiente forma:
cuadro_busqueda$clearElement()
# Se envía texto al elemento pero debe ser en formato lista
cuadro_busqueda$sendKeysToElement(list(paste0("Municipalidad de Heredia")))
# xpath para buscar el elemento
click_busqueda <- '//*[@id="sidebar"]/div[1]/form[1]/div/div[1]/div/input[2]'
# Indicaciones para dar click
remDr$findElement("xpath",click_busqueda)$clickElement()
# El texto se puede limpiar de la siguiente forma:
cuadro_busqueda$clearElement()
# Se envía texto al elemento pero debe ser en formato lista
cuadro_busqueda$sendKeysToElement(list(paste0("Municipalidad de Heredia Costa Rica")))
# xpath para buscar el elemento
click_busqueda <- '//*[@id="sidebar"]/div[1]/form[1]/div/div[1]/div/input[2]'
# Indicaciones para dar click
remDr$findElement("xpath",click_busqueda)$clickElement()
resultados_busqueda <- "/html/body/div/div[1]/div[5]/div[2]/ul/li/a"
cl_result <- remDr$findElements("xpath",resultados_busqueda)
cl_result[[1]]$getElementText())
cl_result[[1]]$getElementText()
#| warning: false
#| eval: false
library(stringdist) # Comparar similitud de strings
library(RSelenium) # RSelenium
library(tidyverse) #
library(seleniumPipes) # Implementa W3C webdriver
library(netstat) # Para el free_port()
# Empezar el servidor
rs_driver_object <- rsDriver(browser = 'chrome', # Se utilizará Google Chrome
chromever = 'latest', # Versión de Chrome
verbose = FALSE, # No incluir mensajes de estado
port = free_port(), # Se utiliza un puerto libre
check = TRUE) # Checar si hay nuevas versiones
# crear un objeto cliente
remDr <- rs_driver_object$client
# Se navega a la página de interés
remDr$navigate('https://www.openstreetmap.org') #
# Se asigna el xpath a una variable para simplificar el código
xpath_cuadro <- "/html/body/div/div[1]/div[1]/form[1]/div/div[1]/div/input[1]"
# Se busca en el web driver
cuadro_busqueda <- remDr$findElement("xpath",xpath_cuadro)
# Se envía texto al elemento pero debe ser en formato lista
cuadro_busqueda$sendKeysToElement(list(paste0("Municipalidad de ",
cant.sp$canton[1], " Costa Rica")))
# El texto se puede limpiar de la siguiente forma:
cuadro_busqueda$clearElement()
# Se envía texto al elemento pero debe ser en formato lista
cuadro_busqueda$sendKeysToElement(list(paste0("Municipalidad de Heredia Costa Rica")))
# xpath para buscar el elemento
click_busqueda <- '//*[@id="sidebar"]/div[1]/form[1]/div/div[1]/div/input[2]'
# Indicaciones para dar click
remDr$findElement("xpath",click_busqueda)$clickElement()
# El texto se puede limpiar de la siguiente forma:
cuadro_busqueda$clearElement()
# Se envía texto al elemento pero debe ser en formato lista
cuadro_busqueda$sendKeysToElement(list(paste0("Municipalidad de Heredia Costa Rica")))
# xpath para buscar el elemento
click_busqueda <- '//*[@id="sidebar"]/div[1]/form[1]/div/div[1]/div/input[2]'
# Indicaciones para dar click
remDr$findElement("xpath",click_busqueda)$clickElement()
# xpath para identificar los resultados visibles
resultados_busqueda <- "/html/body/div/div[1]/div[5]/div[2]/ul/li/a"
# Se utiliza "findElements" ya que se desean todos los elementos
cl_result <- remDr$findElements("xpath",resultados_busqueda)
cl_result[[1]]$getElementText()
for (i in 1:length(cl_result)) {
cl_result[[i]]$getElementText()
}
for (i in 1:length(cl_result)) {
print(cl_result[[i]]$getElementText())
}
# El texto se puede limpiar de la siguiente forma:
cuadro_busqueda$clearElement()
# Se envía texto al elemento pero debe ser en formato lista
cuadro_busqueda$sendKeysToElement(list(paste0("Municipalidad de Heredia")))
# xpath para buscar el elemento
click_busqueda <- '//*[@id="sidebar"]/div[1]/form[1]/div/div[1]/div/input[2]'
# Indicaciones para dar click
remDr$findElement("xpath",click_busqueda)$clickElement()
# xpath para identificar los resultados visibles
resultados_busqueda <- "/html/body/div/div[1]/div[5]/div[2]/ul/li/a"
# Se utiliza "findElements" ya que se desean todos los elementos
cl_result <- remDr$findElements("xpath",resultados_busqueda)
# Indicaciones para dar click
remDr$findElement("xpath",click_busqueda)$clickElement()
# Indicaciones para dar click
remDr$findElement("xpath",click_busqueda)$clickElement()
# Se envía texto al elemento pero debe ser en formato lista
cuadro_busqueda$sendKeysToElement(list(paste0("Municipalidad Heredia")))
# xpath para buscar el elemento
click_busqueda <- '//*[@id="sidebar"]/div[1]/form[1]/div/div[1]/div/input[2]'
# El texto se puede limpiar de la siguiente forma:
cuadro_busqueda$clearElement()
# Se envía texto al elemento pero debe ser en formato lista
cuadro_busqueda$sendKeysToElement(list(paste0("Municipalidad Heredia")))
# xpath para buscar el elemento
click_busqueda <- '//*[@id="sidebar"]/div[1]/form[1]/div/div[1]/div/input[2]'
# Indicaciones para dar click
remDr$findElement("xpath",click_busqueda)$clickElement()
# Se envía texto al elemento pero debe ser en formato lista
cuadro_busqueda$sendKeysToElement(list(paste0("Municipalidad Heredia")))
# xpath para buscar el elemento
click_busqueda <- '//*[@id="sidebar"]/div[1]/form[1]/div/div[1]/div/input[2]'
# Indicaciones para dar click
remDr$findElement("xpath",click_busqueda)$clickElement()
# xpath para identificar los resultados visibles
resultados_busqueda <- "/html/body/div/div[1]/div[5]/div[2]/ul/li/a"
# Se utiliza "findElements" ya que se desean todos los elementos
cl_result <- remDr$findElements("xpath",resultados_busqueda)
for (i in 1:length(cl_result)) {
print(cl_result[[i]]$getElementText())
}
for (i in 1:length(cl_result)) {
print(as.character(cl_result[[i]]$getElementText()))
}
for (i in 1:length(cl_result)) {
print(as.character(cl_result[[i]]$getElementText()))
}
# xpath para identificar los resultados visibles
resultados_busqueda <- "/html/body/div/div[1]/div[5]/div[2]/ul/li/a"
# Se utiliza "findElements" ya que se desean todos los elementos
cl_result <- remDr$findElements("xpath",resultados_busqueda)
for (i in 1:length(cl_result)) {
print(as.character(cl_result[[i]]$getElementText()))
}
nombres_resultado <- data.frame(matrix(nrow = 0, ncol = 1))
for (i in 1:length(cl_result)) {
nombres_resultado[i,1] <- as.character(cl_result[[i]]$getElementText())
print(as.character(cl_result[[i]]$getElementText()))
}
View(nombres_resultado)
colnames(nombres_resultado) <- "Nombre"
nombres_resultado <- data.frame(matrix(nrow = 0, ncol = 2))
colnames(nombres_resultado) <- c("Nombre","Similitud")
nombres_resultado <- data.frame(matrix(nrow = 0, ncol = 2))
colnames(nombres_resultado) <- c("Nombre","Similitud")
for (i in 1:length(cl_result)) {
# Se añade al dataframe
nombres_resultado[i,1] <- as.character(cl_result[[i]]$getElementText())
# Similitud
nombres_resultado[i,2] <- stringsim("Municipalidad Heredia",nombres_resultado[i,1])
# Para ver los resultados en la consola
print(as.character(cl_result[[i]]$getElementText()))
}
View(nombres_resultado)
str_split(lista_resultados[i,1],",")[[1]][1]
str_split(nombres_resultado[i,1],",")[[1]][1]
nombres_resultado <- data.frame(matrix(nrow = 0, ncol = 3))
colnames(nombres_resultado) <- c("Nombre_completo","Nombre","Similitud")
for (i in 1:length(cl_result)) {
# Se añade al dataframe
nombres_resultado[i,1] <- as.character(cl_result[[i]]$getElementText())
# Se divide por la coma y se selecciona el primer resultado
nombres_resultado[it_result,2] <- str_split(nombres_resultado[i,1],",")[[1]][1]
# Similitud
nombres_resultado[i,3] <- stringsim("Municipalidad Heredia",nombres_resultado[i,1])
# Para ver los resultados en la consola
print(as.character(cl_result[[i]]$getElementText()))
}
for (i in 1:length(cl_result)) {
# Se añade al dataframe
nombres_resultado[i,1] <- as.character(cl_result[[i]]$getElementText())
# Se divide por la coma y se selecciona el primer resultado
nombres_resultado[i,2] <- str_split(nombres_resultado[i,1],",")[[1]][1]
# Similitud
nombres_resultado[i,3] <- stringsim("Municipalidad Heredia",nombres_resultado[i,1])
# Para ver los resultados en la consola
print(as.character(cl_result[[i]]$getElementText()))
}
View(nombres_resultado)
nombres_resultado <- data.frame(matrix(nrow = 0, ncol = 3))
colnames(nombres_resultado) <- c("Nombre_completo","Nombre","Similitud")
for (i in 1:length(cl_result)) {
# Se añade al dataframe
nombres_resultado[i,1] <- as.character(cl_result[[i]]$getElementText())
# Se divide por la coma y se selecciona el primer resultado
nombres_resultado[i,2] <- str_split(nombres_resultado[i,1],",")[[1]][1]
# Similitud
nombres_resultado[i,3] <- stringsim("Municipalidad Heredia",nombres_resultado[i,2])
# Para ver los resultados en la consola
print(as.character(cl_result[[i]]$getElementText()))
}
#|include: false
# Para mostrar la tabla
kable(head(tabla[,2:5]), format = "html",
table.attr = "style='width:30%;'",row.names = FALSE) %>%
kableExtra::kable_styling()
#|include: false
# Para mostrar la tabla
kableExtra::kable(head(tabla[,2:5]), format = "html",
table.attr = "style='width:30%;'",row.names = FALSE) %>%
kableExtra::kable_styling()
#|include: false
# Para mostrar la tabla
kableExtra::kable(head(nombres_resultado), format = "html",
table.attr = "style='width:30%;'",row.names = FALSE) %>%
kableExtra::kable_styling()
#| warning: false
#| eval: true
library(osmdata) #
library(tidyverse) #
library(sf) #
library(kableExtra) #
# Cantones
cant.sp <- sf::read_sf("sp/LimiteCantonal5K_.shp")
# Se transforma a WGS84
bbox_wgs84 <- st_bbox(st_transform(cant.sp, crs = "WGS84"))
# Se extraen los datos con los límites de la capa cant.sp
datos_muni <- opq(bbox = bbox_wgs84) %>%
add_osm_feature(key = "amenity",
value = 'townhall',
value_exact = F) %>%
osmdata_sf()
#| warning: false
#| eval: false
library(osmdata) #
library(tidyverse) #
library(sf) #
library(kableExtra) #
# Cantones
cant.sp <- sf::read_sf("sp/LimiteCantonal5K_.shp")
# Se transforma a WGS84
bbox_wgs84 <- st_bbox(st_transform(cant.sp, crs = "WGS84"))
# Se extraen los datos con los límites de la capa cant.sp
datos_muni <- opq(bbox = bbox_wgs84) %>%
add_osm_feature(key = "amenity",
value = 'townhall',
value_exact = F) %>%
osmdata_sf()
# Se extraen los datos con los límites de la capa cant.sp
datos_muni <- opq(bbox = bbox_wgs84) %>%
add_osm_feature(key = "amenity",
value = 'townhall',
value_exact = F) %>%
osmdata_sf()
